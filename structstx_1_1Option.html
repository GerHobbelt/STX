<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=9" />
    <meta name="generator" content="Doxygen 1.8.13" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>STX: stx::Option&lt; T &gt; Struct Template Reference</title>
    <link href="tabs.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <link href="styles.css" rel="stylesheet" type="text/css" />
</head>
<body>
    <script>
        /*
                // light mode, dark mode
                color: ["#333", "#DDD"],
                backgroundColor: ["#FFFFFF", "#353535"],
                cardBackgroundColor: ["#F5F5F5", "#2A2A2A"],
                linkColor: ["#3D578C", "#D2991D"],
                headerBackgroundColor: ["#F1F1F1", "#505050"],
                headerHoverBackgroundColor: ["#F5F5F5", "#444"],
                // memtitle, memproto, memitemleft, memitemright 
                docprotoBackgroundColor: ["#FAFAFA", "2A2A2A"]
        */
        function switchTheme() {
            let theme = localStorage.getItem("theme");
            if (theme == "light" || theme == null) {
                document.body.className = "dark-theme";
                localStorage.setItem("theme", "dark");
            } else {
                document.body.className = "";
                localStorage.setItem("theme", "light");
            }
        }
        (function loadTheme() {
            let theme = localStorage.getItem("theme");
            console.log("theme:" + theme);
            if (theme == "light" || theme == null) {
                document.body.className = "";
            } else {
                document.body.className = "dark-theme";
            }
        })();
    </script>
    <div class="theme-switch dimming-wrap" onclick="switchTheme()">
        <div>
            <svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 48 48">
                <path
                    d="M42 6H6c-2.21 0-4 1.79-4 4v28c0 2.21 1.79 4 4 4h36c2.21 0 4-1.79 4-4V10c0-2.21-1.79-4-4-4zm0 32.03H6V9.97h36v28.06zM16 32h5l3 3 3-3h5v-5l3-3-3-3v-5h-5l-3-3-3 3h-5v5l-3 3 3 3v5zm8-14c3.31 0 6 2.69 6 6s-2.69 6-6 6V18z" />
            </svg></div>
    </div>
    <div id="top">
        <!-- do not remove this div, it is closed by doxygen! -->
        <div id="titlearea">
            <table cellspacing="0" cellpadding="0">
                <tbody>
                    <tr style="height: 56px;">
                        <td id="projectlogo"><img alt="Logo"
                                src="eagle.png" /></td>
                        <td id="projectalign" style="padding-left: 0.5em;">
                            <div id="projectname"> STX
                                &#160;<span id="projectnumber">1.0.0</span>
                            </div>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
        <!-- end header part --><!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacestx.html">stx</a></li><li class="navelem"><a class="el" href="structstx_1_1Option.html">Option</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="structstx_1_1Option-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">stx::Option&lt; T &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="option__result_8h_source.html">option_result.h</a>&gt;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
struct stx::Option&lt; T &gt;</h3>

<p>Optional values.</p>
<p>Type <code><a class="el" href="structstx_1_1Option.html">Option</a></code> represents an optional value: every <code><a class="el" href="structstx_1_1Option.html">Option</a></code> is either <code><a class="el" href="structstx_1_1Some.html">Some</a></code> and contains a value, or <code>None</code>, and does not. They have a number of uses:</p>
<ul>
<li>Initial values</li>
<li>Return values for functions that are not defined over their entire input range (partial functions)</li>
<li>Return value for otherwise reporting simple errors, where <code>None</code> is returned on error</li>
<li>Optional struct fields</li>
<li>Struct fields that can be loaned or "taken"</li>
<li>Optional function arguments</li>
<li>Nullable pointers</li>
<li>Swapping things out of difficult situations</li>
</ul>
<p><code><a class="el" href="structstx_1_1Option.html">Option</a></code>'s are commonly paired with pattern matching to query the presence of a value and take action, always accounting for the <code>None</code>s case.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> divide = [](<span class="keywordtype">double</span> numerator, <span class="keywordtype">double</span> denominator) -&gt; Option&lt;double&gt; {</div><div class="line">  <span class="keywordflow">if</span> (denominator == 0.0) {</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="namespacestx.html#a5cc62cda4ca89a8ebd4b9fb212fe30c4">None</a>;</div><div class="line">  } <span class="keywordflow">else</span> {</div><div class="line">    <span class="keywordflow">return</span> Some(numerator / denominator);</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// The return value of the function is an option</span></div><div class="line"><span class="keyword">auto</span> result = divide(2.0, 3.0);</div><div class="line">result.match([](<span class="keywordtype">double</span>&amp; <a class="code" href="structstx_1_1Option.html#a1a4235a790f4a64af1877ec8fd85668d">value</a>) { std::cout &lt;&lt; value &lt;&lt; std::endl; },</div><div class="line">             []() { std::cout &lt;&lt; <span class="stringliteral">&quot;has no value&quot;</span> &lt;&lt; std::endl; });</div></div><!-- fragment --><h1>Constexpr ?</h1>
<p>C++ 20 and above </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aeaa044f1723c0cc20cb7690d8fe4e490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaa044f1723c0cc20cb7690d8fe4e490">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structstx_1_1Option.html">stx::Option</a>&lt; T &gt;::<a class="el" href="structstx_1_1Option.html#aeaa044f1723c0cc20cb7690d8fe4e490">value_type</a> =  T</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aded24f2b34b4e8898e0b21ab4e36b58b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aded24f2b34b4e8898e0b21ab4e36b58b">&#9670;&nbsp;</a></span>Option() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structstx_1_1Option.html">stx::Option</a>&lt; T &gt;::<a class="el" href="structstx_1_1Option.html">Option</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4932534a2ba009b62edbd0fd7125cc47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4932534a2ba009b62edbd0fd7125cc47">&#9670;&nbsp;</a></span>Option() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structstx_1_1Option.html">stx::Option</a>&lt; T &gt;::<a class="el" href="structstx_1_1Option.html">Option</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1Some.html">Some</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>some</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a98b24bcb392206761ccabf30dab713d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98b24bcb392206761ccabf30dab713d1">&#9670;&nbsp;</a></span>Option() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structstx_1_1Option.html">stx::Option</a>&lt; T &gt;::<a class="el" href="structstx_1_1Option.html">Option</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1Some.html">Some</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>some</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad8f98364c4756f781e95125945001d7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8f98364c4756f781e95125945001d7b">&#9670;&nbsp;</a></span>Option() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structstx_1_1Option.html">stx::Option</a>&lt; T &gt;::<a class="el" href="structstx_1_1Option.html">Option</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1NoneType.html">NoneType</a> const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5a0a5aba40a4e482ab05c805dd96eee6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a0a5aba40a4e482ab05c805dd96eee6">&#9670;&nbsp;</a></span>Option() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstx_1_1Option.html">stx::Option</a>&lt; T &gt;::<a class="el" href="structstx_1_1Option.html">Option</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1Option.html">Option</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3d1ac1c52fac8ad58f39e06c24cde578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d1ac1c52fac8ad58f39e06c24cde578">&#9670;&nbsp;</a></span>Option() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstx_1_1Option.html">stx::Option</a>&lt; T &gt;::<a class="el" href="structstx_1_1Option.html">Option</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1Option.html">Option</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7f3582f41b69282b1264bf180b0070a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f3582f41b69282b1264bf180b0070a5">&#9670;&nbsp;</a></span>~Option()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8h.html#a01bc9952272b509c21c0aac4a3081c74">STX_CXX20_DESTRUCTOR_CONSTEXPR</a> <a class="el" href="structstx_1_1Option.html">stx::Option</a>&lt; T &gt;::~<a class="el" href="structstx_1_1Option.html">Option</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7fe69cb81556133f27e53851753578ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fe69cb81556133f27e53851753578ed">&#9670;&nbsp;</a></span>AND()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structstx_1_1Option.html">stx::Option</a>&lt; T &gt;::AND </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1Option.html">Option</a>&lt; U &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>cmp</em></td><td>)</td>
          <td> &amp;&amp; -&gt; <a class="el" href="structstx_1_1Option.html">Option</a>&lt;U&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <code>None</code> if the option is <code>None</code>, otherwise returns <code>cmp</code>.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><a class="code" href="structstx_1_1Option.html#aded24f2b34b4e8898e0b21ab4e36b58b">Option</a> a = Some(2);</div><div class="line">Option&lt;string&gt; b = <a class="code" href="namespacestx.html#a5cc62cda4ca89a8ebd4b9fb212fe30c4">None</a>;</div><div class="line">ASSERT_EQ(move(a).<a class="code" href="structstx_1_1Option.html#a7fe69cb81556133f27e53851753578ed">AND</a>(move(b)), <a class="code" href="namespacestx.html#a5cc62cda4ca89a8ebd4b9fb212fe30c4">None</a>);</div><div class="line"></div><div class="line">Option&lt;int&gt; c = <a class="code" href="namespacestx.html#a5cc62cda4ca89a8ebd4b9fb212fe30c4">None</a>;</div><div class="line"><a class="code" href="structstx_1_1Option.html#aded24f2b34b4e8898e0b21ab4e36b58b">Option</a> d = Some(<span class="stringliteral">&quot;foo&quot;</span>s);</div><div class="line">ASSERT_EQ(move(c).<a class="code" href="structstx_1_1Option.html#a7fe69cb81556133f27e53851753578ed">AND</a>(move(d)), <a class="code" href="namespacestx.html#a5cc62cda4ca89a8ebd4b9fb212fe30c4">None</a>);</div><div class="line"></div><div class="line"><a class="code" href="structstx_1_1Option.html#aded24f2b34b4e8898e0b21ab4e36b58b">Option</a> e = Some(2);</div><div class="line"><a class="code" href="structstx_1_1Option.html#aded24f2b34b4e8898e0b21ab4e36b58b">Option</a> f = Some(<span class="stringliteral">&quot;foo&quot;</span>s);</div><div class="line">ASSERT_EQ(move(e).<a class="code" href="structstx_1_1Option.html#a7fe69cb81556133f27e53851753578ed">AND</a>(move(f)), Some(<span class="stringliteral">&quot;foo&quot;</span>s));</div><div class="line"></div><div class="line">Option&lt;int&gt; g = <a class="code" href="namespacestx.html#a5cc62cda4ca89a8ebd4b9fb212fe30c4">None</a>;</div><div class="line">Option&lt;string&gt; h = <a class="code" href="namespacestx.html#a5cc62cda4ca89a8ebd4b9fb212fe30c4">None</a>;</div><div class="line">ASSERT_EQ(move(g).<a class="code" href="structstx_1_1Option.html#a7fe69cb81556133f27e53851753578ed">AND</a>(move(h)), <a class="code" href="namespacestx.html#a5cc62cda4ca89a8ebd4b9fb212fe30c4">None</a>);</div></div><!-- fragment --> 
</div>
</div>
<a id="a9eb10550b41c4cca540a94d0136807d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eb10550b41c4cca540a94d0136807d0">&#9670;&nbsp;</a></span>and_then()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structstx_1_1Option.html">stx::Option</a>&lt; T &gt;::and_then </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> &amp;&amp; -&gt; <a class="el" href="namespacestx.html#a2b0a348596751ac8e1ccbe193fad671c">invoke_result</a>&lt;Fn&amp;&amp;, T&amp;&amp;&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <code>None</code> if the option is <code>None</code>, otherwise calls <code>op</code> with the wrapped value and returns the result.</p>
<p><a class="el" href="structstx_1_1Some.html">Some</a> languages call this operation flatmap.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> sq = [] (<span class="keyword">auto</span> x) -&gt; Option&lt;int&gt; { <span class="keywordflow">return</span> Some(x * x); };</div><div class="line"><span class="keyword">auto</span> nope = [] (<span class="keyword">auto</span>) -&gt; Option&lt;int&gt; { <span class="keywordflow">return</span> <a class="code" href="namespacestx.html#a5cc62cda4ca89a8ebd4b9fb212fe30c4">None</a>; };</div><div class="line"></div><div class="line">ASSERT_EQ(<a class="code" href="namespacestx.html#af3dd9531b7d03154feb5ab0b5230cd84">make_some</a>(2).<a class="code" href="structstx_1_1Option.html#a9eb10550b41c4cca540a94d0136807d0">and_then</a>(sq).<a class="code" href="structstx_1_1Option.html#a9eb10550b41c4cca540a94d0136807d0">and_then</a>(sq), Some(16));</div><div class="line">ASSERT_EQ(<a class="code" href="namespacestx.html#af3dd9531b7d03154feb5ab0b5230cd84">make_some</a>(2).<a class="code" href="structstx_1_1Option.html#a9eb10550b41c4cca540a94d0136807d0">and_then</a>(sq).<a class="code" href="structstx_1_1Option.html#a9eb10550b41c4cca540a94d0136807d0">and_then</a>(nope), <a class="code" href="namespacestx.html#a5cc62cda4ca89a8ebd4b9fb212fe30c4">None</a>);</div><div class="line">ASSERT_EQ(<a class="code" href="namespacestx.html#af3dd9531b7d03154feb5ab0b5230cd84">make_some</a>(2).<a class="code" href="structstx_1_1Option.html#a9eb10550b41c4cca540a94d0136807d0">and_then</a>(nope).<a class="code" href="structstx_1_1Option.html#a9eb10550b41c4cca540a94d0136807d0">and_then</a>(sq), <a class="code" href="namespacestx.html#a5cc62cda4ca89a8ebd4b9fb212fe30c4">None</a>);</div><div class="line">ASSERT_EQ(make_none&lt;int&gt;().<a class="code" href="structstx_1_1Option.html#a9eb10550b41c4cca540a94d0136807d0">and_then</a>(sq).<a class="code" href="structstx_1_1Option.html#a9eb10550b41c4cca540a94d0136807d0">and_then</a>(sq), <a class="code" href="namespacestx.html#a5cc62cda4ca89a8ebd4b9fb212fe30c4">None</a>);</div></div><!-- fragment --> 
</div>
</div>
<a id="ac492a01977739952ae35a3993bcc26bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac492a01977739952ae35a3993bcc26bf">&#9670;&nbsp;</a></span>as_cref() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structstx_1_1Option.html">stx::Option</a>&lt; T &gt;::as_cref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp; -&gt; <a class="el" href="structstx_1_1Option.html">Option</a>&lt;<a class="el" href="namespacestx.html#ade174634b9a4ee8ee45d74045538b591">ConstRef</a>&lt;T&gt;&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts from <code><a class="el" href="structstx_1_1Option.html">Option</a>&lt;T&gt; const&amp;</code> or <code><a class="el" href="structstx_1_1Option.html">Option</a>&lt;T&gt; &amp;</code> to <code><a class="el" href="structstx_1_1Option.html">Option</a>&lt;ConstRef&lt;T&gt;&gt;</code>.</p>
<h1>NOTE</h1>
<p><code>ConstRef&lt;T&gt;</code> is an alias for <code>std::reference_wrapper&lt;T const&gt;</code> and guides against reference-collapsing </p>

</div>
</div>
<a id="ad95fba7ff6153367aa973dc5f407b994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad95fba7ff6153367aa973dc5f407b994">&#9670;&nbsp;</a></span>as_cref() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structstx_1_1Option.html">stx::Option</a>&lt; T &gt;::as_cref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;&amp; -&gt;  <a class="el" href="structstx_1_1Option.html">Option</a>&lt; <a class="el" href="namespacestx.html#ade174634b9a4ee8ee45d74045538b591">ConstRef</a>&lt; T &gt;&gt;=delete</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a524916040d1ee38604a7e5c4b849aa67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a524916040d1ee38604a7e5c4b849aa67">&#9670;&nbsp;</a></span>as_ref() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structstx_1_1Option.html">stx::Option</a>&lt; T &gt;::as_ref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp; -&gt; <a class="el" href="structstx_1_1Option.html">Option</a>&lt;<a class="el" href="namespacestx.html#a602d285852b6664cc71937407fe7484a">MutRef</a>&lt;T&gt;&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts from <code><a class="el" href="structstx_1_1Option.html">Option</a>&lt;T&gt;</code> to <code><a class="el" href="structstx_1_1Option.html">Option</a>&lt;MutRef&lt;T&gt;&gt;</code>.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> mutate = [](Option&lt;int&gt;&amp; r) {</div><div class="line"> r.as_ref().match([](Ref&lt;int&gt; ref) { ref.get() = 42; },</div><div class="line">                  []() { });</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">auto</span> x = <a class="code" href="namespacestx.html#af3dd9531b7d03154feb5ab0b5230cd84">make_some</a>(2);</div><div class="line">mutate(x);</div><div class="line">ASSERT_EQ(x, Some(42));</div><div class="line"></div><div class="line"><span class="keyword">auto</span> y = make_none&lt;int&gt;();</div><div class="line">mutate(y);</div><div class="line">ASSERT_EQ(y, <a class="code" href="namespacestx.html#a5cc62cda4ca89a8ebd4b9fb212fe30c4">None</a>);</div></div><!-- fragment --> 
</div>
</div>
<a id="a648aa3dca81896f35c7d95384374da2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a648aa3dca81896f35c7d95384374da2d">&#9670;&nbsp;</a></span>as_ref() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structstx_1_1Option.html">stx::Option</a>&lt; T &gt;::as_ref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp; -&gt; <a class="el" href="structstx_1_1Option.html">Option</a>&lt;<a class="el" href="namespacestx.html#ade174634b9a4ee8ee45d74045538b591">ConstRef</a>&lt;T&gt;&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9e7d17c0bc0ac77d392f29b6c417b568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e7d17c0bc0ac77d392f29b6c417b568">&#9670;&nbsp;</a></span>as_ref() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structstx_1_1Option.html">stx::Option</a>&lt; T &gt;::as_ref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp; -&gt;  <a class="el" href="structstx_1_1Option.html">Option</a>&lt; <a class="el" href="namespacestx.html#a602d285852b6664cc71937407fe7484a">MutRef</a>&lt; T &gt;&gt;=delete</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a75d44fa46d4e8a13f13ea2f152e605be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75d44fa46d4e8a13f13ea2f152e605be">&#9670;&nbsp;</a></span>as_ref() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structstx_1_1Option.html">stx::Option</a>&lt; T &gt;::as_ref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;&amp; -&gt;  <a class="el" href="structstx_1_1Option.html">Option</a>&lt; <a class="el" href="namespacestx.html#ade174634b9a4ee8ee45d74045538b591">ConstRef</a>&lt; T &gt;&gt;=delete</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1363ce21fbaf04d5f3c61f53756c3078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1363ce21fbaf04d5f3c61f53756c3078">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structstx_1_1Option.html">stx::Option</a>&lt; T &gt;::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="structstx_1_1Option.html">Option</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a copy of the option and its contents.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><a class="code" href="structstx_1_1Option.html#aded24f2b34b4e8898e0b21ab4e36b58b">Option</a> x  = Some(8);</div><div class="line"></div><div class="line">ASSERT_EQ(x, x.clone());</div></div><!-- fragment --> 
</div>
</div>
<a id="adf04db7e33e5c2c669c5b5cef5059dcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf04db7e33e5c2c669c5b5cef5059dcd">&#9670;&nbsp;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename CmpType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="structstx_1_1Option.html">stx::Option</a>&lt; T &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">CmpType const &amp;&#160;</td>
          <td class="paramname"><em>cmp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <code>true</code> if the option is a <code><a class="el" href="structstx_1_1Some.html">Some</a></code> value containing the given value.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><a class="code" href="structstx_1_1Option.html#aded24f2b34b4e8898e0b21ab4e36b58b">Option</a> x = Some(2);</div><div class="line">ASSERT_TRUE(x.contains(2));</div><div class="line"></div><div class="line"><a class="code" href="structstx_1_1Option.html#aded24f2b34b4e8898e0b21ab4e36b58b">Option</a> y = Some(3);</div><div class="line">ASSERT_FALSE(y.contains(2));</div><div class="line"></div><div class="line">Option&lt;int&gt; z = <a class="code" href="namespacestx.html#a5cc62cda4ca89a8ebd4b9fb212fe30c4">None</a>;</div><div class="line">ASSERT_FALSE(z.contains(2));</div></div><!-- fragment --> 
</div>
</div>
<a id="a3b34aa2d9cc4963fb1dfa0bb98e441b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b34aa2d9cc4963fb1dfa0bb98e441b6">&#9670;&nbsp;</a></span>exists()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename UnaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="structstx_1_1Option.html">stx::Option</a>&lt; T &gt;::exists </td>
          <td>(</td>
          <td class="paramtype">UnaryPredicate &amp;&amp;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the value of evaluating the <code>predicate</code> on the contained value if the <code><a class="el" href="structstx_1_1Option.html">Option</a></code> is a <code><a class="el" href="structstx_1_1Some.html">Some</a></code>, else returns <code>false</code>.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><a class="code" href="structstx_1_1Option.html#aded24f2b34b4e8898e0b21ab4e36b58b">Option</a> x = Some(2);</div><div class="line"><span class="keyword">auto</span> even = [](<span class="keyword">auto</span> x) { <span class="keywordflow">return</span> x == 2; };</div><div class="line">ASSERT_TRUE(x.exists(even));</div></div><!-- fragment --> 
</div>
</div>
<a id="a5c55cd0779cd34d81d687ab8accf833c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c55cd0779cd34d81d687ab8accf833c">&#9670;&nbsp;</a></span>expect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structstx_1_1Option.html">stx::Option</a>&lt; T &gt;::expect </td>
          <td>(</td>
          <td class="paramtype">std::string_view const &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td> &amp;&amp; -&gt; T </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unwraps an option, yielding the content of a <code><a class="el" href="structstx_1_1Some.html">Some</a></code>.</p>
<h1>Panics</h1>
<p>Panics if the value is a <code>None</code> with a custom panic message provided by <code>msg</code>.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><a class="code" href="structstx_1_1Option.html#aded24f2b34b4e8898e0b21ab4e36b58b">Option</a> x = Some(<span class="stringliteral">&quot;value&quot;</span>s);</div><div class="line">ASSERT_EQ(move(x).<a class="code" href="structstx_1_1Option.html#a5c55cd0779cd34d81d687ab8accf833c">expect</a>(<span class="stringliteral">&quot;the world is ending&quot;</span>), <span class="stringliteral">&quot;value&quot;</span>);</div><div class="line"></div><div class="line">Option&lt;string&gt; y = <a class="code" href="namespacestx.html#a5cc62cda4ca89a8ebd4b9fb212fe30c4">None</a>;</div><div class="line">ASSERT_DEATH(move(y).<a class="code" href="structstx_1_1Option.html#a5c55cd0779cd34d81d687ab8accf833c">expect</a>(<span class="stringliteral">&quot;the world is ending&quot;</span>)); <span class="comment">// panics with</span></div><div class="line">                                                         <span class="comment">// the world is</span></div><div class="line">                                                         <span class="comment">// ending</span></div></div><!-- fragment --> 
</div>
</div>
<a id="abfca7b1c0cfc9d5f1293af3197eae580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfca7b1c0cfc9d5f1293af3197eae580">&#9670;&nbsp;</a></span>expect_none()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structstx_1_1Option.html">stx::Option</a>&lt; T &gt;::expect_none </td>
          <td>(</td>
          <td class="paramtype">std::string_view const &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unwraps an option, expecting <code>None</code> and returning nothing.</p>
<h1>Panics</h1>
<p>Panics if the value is a <code><a class="el" href="structstx_1_1Some.html">Some</a></code>, with a panic message.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> divide = [](<span class="keywordtype">double</span> num, <span class="keywordtype">double</span> denom) -&gt; Option&lt;double&gt; {</div><div class="line"><span class="keywordflow">if</span> (denom == 0.0) <span class="keywordflow">return</span> <a class="code" href="namespacestx.html#a5cc62cda4ca89a8ebd4b9fb212fe30c4">None</a>;</div><div class="line"> <span class="keywordflow">return</span> Some(num / denom);</div><div class="line">};</div><div class="line"></div><div class="line">ASSERT_DEATH(divide(0.0, 1.0).<a class="code" href="structstx_1_1Option.html#abfca7b1c0cfc9d5f1293af3197eae580">expect_none</a>());</div><div class="line">ASSERT_NO_THROW(divide(1.0, 0.0).<a class="code" href="structstx_1_1Option.html#abfca7b1c0cfc9d5f1293af3197eae580">expect_none</a>());</div></div><!-- fragment --> 
</div>
</div>
<a id="a879fd4465ee903efc53097f7c9e88cdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a879fd4465ee903efc53097f7c9e88cdc">&#9670;&nbsp;</a></span>filter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename UnaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structstx_1_1Option.html">stx::Option</a>&lt; T &gt;::filter </td>
          <td>(</td>
          <td class="paramtype">UnaryPredicate &amp;&amp;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td> &amp;&amp; -&gt; <a class="el" href="structstx_1_1Option.html">Option</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <code>None</code> if the option is <code>None</code>, otherwise calls <code>predicate</code> with the wrapped value and returns:</p>
<ul>
<li><code><a class="el" href="structstx_1_1Some.html">Some</a>&lt;T&gt;</code> if <code>predicate</code> returns <code>true</code> on invocation on the value.</li>
<li><code>None</code> if <code>predicate</code> returns <code>false</code> on invocation on the value.</li>
</ul>
<p><code><a class="el" href="structstx_1_1Option.html#a879fd4465ee903efc53097f7c9e88cdc">filter()</a></code> lets you decide which elements to keep.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> is_even = [](<span class="keywordtype">int</span> n) -&gt; <span class="keywordtype">bool</span> { <span class="keywordflow">return</span> n % 2 == 0; };</div><div class="line"></div><div class="line">ASSERT_EQ(make_none&lt;int&gt;().<a class="code" href="structstx_1_1Option.html#a879fd4465ee903efc53097f7c9e88cdc">filter</a>(is_even), <a class="code" href="namespacestx.html#a5cc62cda4ca89a8ebd4b9fb212fe30c4">None</a>);</div><div class="line">ASSERT_EQ(<a class="code" href="namespacestx.html#af3dd9531b7d03154feb5ab0b5230cd84">make_some</a>(3).<a class="code" href="structstx_1_1Option.html#a879fd4465ee903efc53097f7c9e88cdc">filter</a>(is_even), <a class="code" href="namespacestx.html#a5cc62cda4ca89a8ebd4b9fb212fe30c4">None</a>);</div><div class="line">ASSERT_EQ(<a class="code" href="namespacestx.html#af3dd9531b7d03154feb5ab0b5230cd84">make_some</a>(4).<a class="code" href="structstx_1_1Option.html#a879fd4465ee903efc53097f7c9e88cdc">filter</a>(is_even), Some(4));</div></div><!-- fragment --> 
</div>
</div>
<a id="a4898df8e8700946b0a5a04ecbc53fdad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4898df8e8700946b0a5a04ecbc53fdad">&#9670;&nbsp;</a></span>filter_not()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename UnaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structstx_1_1Option.html">stx::Option</a>&lt; T &gt;::filter_not </td>
          <td>(</td>
          <td class="paramtype">UnaryPredicate &amp;&amp;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td> &amp;&amp; -&gt; <a class="el" href="structstx_1_1Option.html">Option</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <code>None</code> if the option is <code>None</code>, otherwise calls <code>predicate</code> with the wrapped value and returns:</p>
<ul>
<li><code><a class="el" href="structstx_1_1Some.html">Some</a>&lt;T&gt;</code> if <code>predicate</code> returns <code>false</code> on invocation on the value.</li>
<li><code>None</code> if <code>predicate</code> returns <code>true</code> on invocation on the value.</li>
</ul>
<p><code><a class="el" href="structstx_1_1Option.html#a4898df8e8700946b0a5a04ecbc53fdad">filter_not()</a></code> lets you decide which elements to keep.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> is_even = [](<span class="keywordtype">int</span> n) -&gt; <span class="keywordtype">bool</span> { <span class="keywordflow">return</span> n % 2 == 0; };</div><div class="line"></div><div class="line">ASSERT_EQ(make_none&lt;int&gt;().<a class="code" href="structstx_1_1Option.html#a4898df8e8700946b0a5a04ecbc53fdad">filter_not</a>(is_even), <a class="code" href="namespacestx.html#a5cc62cda4ca89a8ebd4b9fb212fe30c4">None</a>);</div><div class="line">ASSERT_EQ(<a class="code" href="namespacestx.html#af3dd9531b7d03154feb5ab0b5230cd84">make_some</a>(3).<a class="code" href="structstx_1_1Option.html#a4898df8e8700946b0a5a04ecbc53fdad">filter_not</a>(is_even), Some(3));</div><div class="line">ASSERT_EQ(<a class="code" href="namespacestx.html#af3dd9531b7d03154feb5ab0b5230cd84">make_some</a>(4).<a class="code" href="structstx_1_1Option.html#a4898df8e8700946b0a5a04ecbc53fdad">filter_not</a>(is_even), <a class="code" href="namespacestx.html#a5cc62cda4ca89a8ebd4b9fb212fe30c4">None</a>);</div></div><!-- fragment --> 
</div>
</div>
<a id="a128eea3f6f6fc53507d53997f6c7b2f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a128eea3f6f6fc53507d53997f6c7b2f5">&#9670;&nbsp;</a></span>is_none()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="structstx_1_1Option.html">stx::Option</a>&lt; T &gt;::is_none </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <code>true</code> if the option is a <code>None</code> value.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><a class="code" href="structstx_1_1Option.html#aded24f2b34b4e8898e0b21ab4e36b58b">Option</a> x = Some(2);</div><div class="line">ASSERT_FALSE(x.is_none());</div><div class="line"></div><div class="line">Option&lt;int&gt; y = <a class="code" href="namespacestx.html#a5cc62cda4ca89a8ebd4b9fb212fe30c4">None</a>;</div><div class="line">ASSERT_TRUE(y.is_none());</div></div><!-- fragment --> 
</div>
</div>
<a id="ac3b86d7f557309e46e6daa0a9dc0f0e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3b86d7f557309e46e6daa0a9dc0f0e5">&#9670;&nbsp;</a></span>is_some()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="structstx_1_1Option.html">stx::Option</a>&lt; T &gt;::is_some </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <code>true</code> if this <a class="el" href="structstx_1_1Option.html">Option</a> is a <code><a class="el" href="structstx_1_1Some.html">Some</a></code> value.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><a class="code" href="structstx_1_1Option.html#aded24f2b34b4e8898e0b21ab4e36b58b">Option</a> x = Some(2);</div><div class="line">ASSERT_TRUE(x.is_some());</div><div class="line"></div><div class="line">Option&lt;int&gt; y = <a class="code" href="namespacestx.html#a5cc62cda4ca89a8ebd4b9fb212fe30c4">None</a>;</div><div class="line">ASSERT_FALSE(y.is_some());</div></div><!-- fragment --> 
</div>
</div>
<a id="ad243379b32b985a119fc7acd78e3571a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad243379b32b985a119fc7acd78e3571a">&#9670;&nbsp;</a></span>map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structstx_1_1Option.html">stx::Option</a>&lt; T &gt;::map </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> &amp;&amp; -&gt; <a class="el" href="structstx_1_1Option.html">Option</a>&lt;<a class="el" href="namespacestx.html#a2b0a348596751ac8e1ccbe193fad671c">invoke_result</a>&lt;Fn&amp;&amp;, T&amp;&amp;&gt;&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Maps an <code><a class="el" href="structstx_1_1Option.html">Option</a>&lt;T&gt;</code> to <code><a class="el" href="structstx_1_1Option.html">Option</a>&lt;U&gt;</code> by applying a function to a contained value and therefore, consuming/moving the contained value.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<p>Converts an <code><a class="el" href="structstx_1_1Option.html">Option</a>&lt;string&gt;</code> into an <code><a class="el" href="structstx_1_1Option.html">Option</a>&lt;size_t&gt;</code>, consuming the original:</p>
<div class="fragment"><div class="line"><a class="code" href="structstx_1_1Option.html#aded24f2b34b4e8898e0b21ab4e36b58b">Option</a> maybe_string = Some(<span class="stringliteral">&quot;Hello, World!&quot;</span>s);</div><div class="line"><span class="comment">// `Option::map` will only work on Option as an r-value and assumes the</span></div><div class="line"><span class="comment">//  object in it is about to be moved</span></div><div class="line"><span class="keyword">auto</span> maybe_len = move(maybe_string).map([](<span class="keyword">auto</span> s){ <span class="keywordflow">return</span> s.size();</div><div class="line">});</div><div class="line"><span class="comment">// maybe_string is invalid and should not be used from here since we</span></div><div class="line"><span class="comment">// `std::move`-d from it</span></div><div class="line"></div><div class="line">ASSERT_EQ(maybe_len, Some&lt;size_t&gt;(13));</div></div><!-- fragment --> 
</div>
</div>
<a id="a3225e411bcb625bfc7ac2be0d559e0aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3225e411bcb625bfc7ac2be0d559e0aa">&#9670;&nbsp;</a></span>map_or()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Fn , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structstx_1_1Option.html">stx::Option</a>&lt; T &gt;::map_or </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>alt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> &amp;&amp; -&gt; <a class="el" href="namespacestx.html#a2b0a348596751ac8e1ccbe193fad671c">invoke_result</a>&lt;Fn&amp;&amp;, T&amp;&amp;&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies a function to the contained value (if any), or returns the provided alternative (if not).</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><a class="code" href="structstx_1_1Option.html#aded24f2b34b4e8898e0b21ab4e36b58b">Option</a> x = Some(<span class="stringliteral">&quot;foo&quot;</span>s);</div><div class="line"><span class="keyword">auto</span> alt_fn = [](<span class="keyword">auto</span> s) { <span class="keywordflow">return</span> s.size(); };</div><div class="line">ASSERT_EQ(move(x).<a class="code" href="structstx_1_1Option.html#a3225e411bcb625bfc7ac2be0d559e0aa">map_or</a>(alt_fn, 42UL), 3UL);</div><div class="line"></div><div class="line">Option&lt;string&gt; y = <a class="code" href="namespacestx.html#a5cc62cda4ca89a8ebd4b9fb212fe30c4">None</a>;</div><div class="line">ASSERT_EQ(move(y).<a class="code" href="structstx_1_1Option.html#a3225e411bcb625bfc7ac2be0d559e0aa">map_or</a>(alt_fn, 42UL), 42UL);</div></div><!-- fragment --> 
</div>
</div>
<a id="a9d8e1a35a7d35f4585520abd7d11ef0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d8e1a35a7d35f4585520abd7d11ef0e">&#9670;&nbsp;</a></span>map_or_else()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Fn , typename AltFn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structstx_1_1Option.html">stx::Option</a>&lt; T &gt;::map_or_else </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AltFn &amp;&amp;&#160;</td>
          <td class="paramname"><em>alt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> &amp;&amp; -&gt; <a class="el" href="namespacestx.html#a2b0a348596751ac8e1ccbe193fad671c">invoke_result</a>&lt;Fn&amp;&amp;, T&amp;&amp;&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies a function to the contained value (if any), or computes a default (if not).</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><span class="keywordtype">size_t</span> k = 21;</div><div class="line"><span class="keyword">auto</span> map_fn = [] (<span class="keyword">auto</span> s) { <span class="keywordflow">return</span> s.size(); };</div><div class="line"><span class="keyword">auto</span> alt_fn = [&amp;k] () { <span class="keywordflow">return</span> 2UL * k; };</div><div class="line"></div><div class="line"><a class="code" href="structstx_1_1Option.html#aded24f2b34b4e8898e0b21ab4e36b58b">Option</a> x = Some(<span class="stringliteral">&quot;foo&quot;</span>s);</div><div class="line">ASSERT_EQ(move(x).<a class="code" href="structstx_1_1Option.html#a9d8e1a35a7d35f4585520abd7d11ef0e">map_or_else</a>(map_fn, alt_fn), 3);</div><div class="line"></div><div class="line">Option&lt;string&gt; y = <a class="code" href="namespacestx.html#a5cc62cda4ca89a8ebd4b9fb212fe30c4">None</a>;</div><div class="line">ASSERT_EQ(move(y).<a class="code" href="structstx_1_1Option.html#a9d8e1a35a7d35f4585520abd7d11ef0e">map_or_else</a>(map_fn, alt_fn), 42);</div></div><!-- fragment --> 
</div>
</div>
<a id="ad1f2f4af821b288504f003b31dc6cb31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1f2f4af821b288504f003b31dc6cb31">&#9670;&nbsp;</a></span>match() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename SomeFn , typename NoneFn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structstx_1_1Option.html">stx::Option</a>&lt; T &gt;::match </td>
          <td>(</td>
          <td class="paramtype">SomeFn &amp;&amp;&#160;</td>
          <td class="paramname"><em>some_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NoneFn &amp;&amp;&#160;</td>
          <td class="paramname"><em>none_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> &amp;&amp; -&gt; <a class="el" href="namespacestx.html#a2b0a348596751ac8e1ccbe193fad671c">invoke_result</a>&lt;SomeFn&amp;&amp;, T&amp;&amp;&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calls the parameter <code>some_fn</code> with the value if this <code><a class="el" href="structstx_1_1Option.html">Option</a></code> is a <code><a class="el" href="structstx_1_1Some.html">Some</a>&lt;T&gt;</code> variant, else calls <code>none_fn</code>. This <code><a class="el" href="structstx_1_1Option.html">Option</a></code> is consumed afterward.</p>
<p>The return type of both parameters must be convertible. They can also both return nothing ( <code>void</code> ).</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> j = <a class="code" href="namespacestx.html#af3dd9531b7d03154feb5ab0b5230cd84">make_some</a>(<span class="stringliteral">&quot;James&quot;</span>s).match([](<span class="keywordtype">string</span> name) { <span class="keywordflow">return</span> name; },</div><div class="line">                                   []() { <span class="keywordflow">return</span> <span class="stringliteral">&quot;&lt;unidentified&gt;&quot;</span>s; });</div><div class="line">ASSERT_EQ(j, <span class="stringliteral">&quot;James&quot;</span>s);</div><div class="line"></div><div class="line"><span class="keyword">auto</span> k = make_none&lt;string&gt;().<a class="code" href="structstx_1_1Option.html#ad1f2f4af821b288504f003b31dc6cb31">match</a>([](<span class="keywordtype">string</span> name) { <span class="keywordflow">return</span> name; },</div><div class="line">                                   []() { <span class="keywordflow">return</span> <span class="stringliteral">&quot;&lt;unidentified&gt;&quot;</span>s; });</div><div class="line">ASSERT_EQ(k, <span class="stringliteral">&quot;&lt;unidentified&gt;&quot;</span>s);</div></div><!-- fragment --><h1>Notes</h1>
<ul>
<li>The <code><a class="el" href="structstx_1_1Option.html">Option</a></code>'s reference type is passed to the function arguments. i.e. If the <code><a class="el" href="structstx_1_1Option.html">Option</a></code> is an r-value, r-value references are passed to the function arguments <code>some_fn</code> and <code>none_fn</code>. </li>
</ul>

</div>
</div>
<a id="a2ee625c44ccc2c61ba4357b435433509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ee625c44ccc2c61ba4357b435433509">&#9670;&nbsp;</a></span>match() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename SomeFn , typename NoneFn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structstx_1_1Option.html">stx::Option</a>&lt; T &gt;::match </td>
          <td>(</td>
          <td class="paramtype">SomeFn &amp;&amp;&#160;</td>
          <td class="paramname"><em>some_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NoneFn &amp;&amp;&#160;</td>
          <td class="paramname"><em>none_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> &amp; -&gt; <a class="el" href="namespacestx.html#a2b0a348596751ac8e1ccbe193fad671c">invoke_result</a>&lt;SomeFn&amp;&amp;, T&amp;&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4804ae5c057d1ae4236dca1e1fa5e154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4804ae5c057d1ae4236dca1e1fa5e154">&#9670;&nbsp;</a></span>match() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename SomeFn , typename NoneFn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structstx_1_1Option.html">stx::Option</a>&lt; T &gt;::match </td>
          <td>(</td>
          <td class="paramtype">SomeFn &amp;&amp;&#160;</td>
          <td class="paramname"><em>some_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NoneFn &amp;&amp;&#160;</td>
          <td class="paramname"><em>none_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const &amp; -&gt; <a class="el" href="namespacestx.html#a2b0a348596751ac8e1ccbe193fad671c">invoke_result</a>&lt;SomeFn&amp;&amp;, T const&amp;&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8ab0da7b2c4f6396f6467cdf0ba59676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ab0da7b2c4f6396f6467cdf0ba59676">&#9670;&nbsp;</a></span>ok_or()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structstx_1_1Option.html">stx::Option</a>&lt; T &gt;::ok_or </td>
          <td>(</td>
          <td class="paramtype">E&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td> &amp;&amp; -&gt; <a class="el" href="structstx_1_1Result.html">Result</a>&lt;T, E&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Transforms the <code><a class="el" href="structstx_1_1Option.html">Option</a>&lt;T&gt;</code> into a <code><a class="el" href="structstx_1_1Result.html">Result</a>&lt;T, E&gt;</code>, mapping <code><a class="el" href="structstx_1_1Some.html">Some</a>&lt;T&gt;</code> to <code><a class="el" href="structstx_1_1Ok.html">Ok</a>&lt;T&gt;</code> and <code>None</code> to <code><a class="el" href="structstx_1_1Err.html">Err</a>&lt;E&gt;</code>.</p>
<p>Arguments passed to <code>ok_or</code> are eagerly evaluated; if you are passing the result of a function call, it is recommended to use <code>ok_or_else</code>, which is lazily evaluated.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><a class="code" href="structstx_1_1Option.html#aded24f2b34b4e8898e0b21ab4e36b58b">Option</a> x = Some(<span class="stringliteral">&quot;foo&quot;</span>s);</div><div class="line">ASSERT_EQ(move(x).<a class="code" href="structstx_1_1Option.html#a8ab0da7b2c4f6396f6467cdf0ba59676">ok_or</a>(0), Ok(<span class="stringliteral">&quot;foo&quot;</span>s));</div><div class="line"></div><div class="line">Option&lt;string&gt; y = <a class="code" href="namespacestx.html#a5cc62cda4ca89a8ebd4b9fb212fe30c4">None</a>;</div><div class="line">ASSERT_EQ(move(y).<a class="code" href="structstx_1_1Option.html#a8ab0da7b2c4f6396f6467cdf0ba59676">ok_or</a>(0), Err(0));</div></div><!-- fragment --> 
</div>
</div>
<a id="af8075c9a622713eae1e4f4f26a93b67e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8075c9a622713eae1e4f4f26a93b67e">&#9670;&nbsp;</a></span>ok_or_else()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structstx_1_1Option.html">stx::Option</a>&lt; T &gt;::ok_or_else </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> &amp;&amp; -&gt; <a class="el" href="structstx_1_1Result.html">Result</a>&lt;T, <a class="el" href="namespacestx.html#a2b0a348596751ac8e1ccbe193fad671c">invoke_result</a>&lt;Fn&amp;&amp;&gt;&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Transforms the <code><a class="el" href="structstx_1_1Option.html">Option</a>&lt;T&gt;</code> into a <code><a class="el" href="structstx_1_1Result.html">Result</a>&lt;T, E&gt;</code>, mapping <code><a class="el" href="structstx_1_1Some.html">Some</a>&lt;T&gt;</code> to <code><a class="el" href="structstx_1_1Ok.html">Ok</a>&lt;T&gt;</code> and <code>None</code> to <code>Err(op())</code>.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> else_fn = [] () { <span class="keywordflow">return</span> 0; };</div><div class="line"></div><div class="line"><a class="code" href="structstx_1_1Option.html#aded24f2b34b4e8898e0b21ab4e36b58b">Option</a> x = Some(<span class="stringliteral">&quot;foo&quot;</span>s);</div><div class="line">ASSERT_EQ(move(x).<a class="code" href="structstx_1_1Option.html#af8075c9a622713eae1e4f4f26a93b67e">ok_or_else</a>(else_fn), Ok(<span class="stringliteral">&quot;foo&quot;</span>s));</div><div class="line"></div><div class="line">Option&lt;string&gt; y = <a class="code" href="namespacestx.html#a5cc62cda4ca89a8ebd4b9fb212fe30c4">None</a>;</div><div class="line">ASSERT_EQ(move(y).<a class="code" href="structstx_1_1Option.html#af8075c9a622713eae1e4f4f26a93b67e">ok_or_else</a>(else_fn), Err(0));</div></div><!-- fragment --> 
</div>
</div>
<a id="af39297d44cf18a678f71fe9eea0b0b66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af39297d44cf18a678f71fe9eea0b0b66">&#9670;&nbsp;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstx_1_1Option.html">stx::Option</a>&lt; T &gt;::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3986fda5057ae0e23838beaabb0a6707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3986fda5057ae0e23838beaabb0a6707">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="structstx_1_1Option.html">stx::Option</a>&lt; T &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1Option.html">Option</a>&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>cmp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4701944efb2d3e35f2682d526c216d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4701944efb2d3e35f2682d526c216d0c">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="structstx_1_1Option.html">stx::Option</a>&lt; T &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1Some.html">Some</a>&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>cmp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aab40be30586a8dccd6714457a03e4ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab40be30586a8dccd6714457a03e4ec8">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="structstx_1_1Option.html">stx::Option</a>&lt; T &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1NoneType.html">NoneType</a> const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3bb91a7c281b9697dea63c4f1adeb75e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bb91a7c281b9697dea63c4f1adeb75e">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstx_1_1Option.html">Option</a>&amp; <a class="el" href="structstx_1_1Option.html">stx::Option</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1Option.html">Option</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac77a661bd75d9b626aba7a26eecc1c93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac77a661bd75d9b626aba7a26eecc1c93">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstx_1_1Option.html">Option</a>&amp; <a class="el" href="structstx_1_1Option.html">stx::Option</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1Option.html">Option</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9e62156f800c61aac9c98071f4f0c969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e62156f800c61aac9c98071f4f0c969">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="structstx_1_1Option.html">stx::Option</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1Option.html">Option</a>&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>cmp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5f41b05f0f97cbea38d7dd385ed570e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f41b05f0f97cbea38d7dd385ed570e8">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="structstx_1_1Option.html">stx::Option</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1Some.html">Some</a>&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>cmp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a606004ec5662ae1db49f54fed2cd58bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a606004ec5662ae1db49f54fed2cd58bd">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="structstx_1_1Option.html">stx::Option</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1NoneType.html">NoneType</a> const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7845c47770ef65233727d1fb0eb2e876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7845c47770ef65233727d1fb0eb2e876">&#9670;&nbsp;</a></span>OR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structstx_1_1Option.html">stx::Option</a>&lt; T &gt;::OR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1Option.html">Option</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>alt</em></td><td>)</td>
          <td> &amp;&amp; -&gt; <a class="el" href="structstx_1_1Option.html">Option</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the option if it contains a value, otherwise returns <code>alt</code>.</p>
<p>Arguments passed to <code>OR</code> are eagerly evaluated; if you are passing the result of a function call, it is recommended to use <code>or_else</code>, which is lazily evaluated.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><a class="code" href="structstx_1_1Option.html#aded24f2b34b4e8898e0b21ab4e36b58b">Option</a> a = Some(2);</div><div class="line">Option&lt;int&gt; b = <a class="code" href="namespacestx.html#a5cc62cda4ca89a8ebd4b9fb212fe30c4">None</a>;</div><div class="line">ASSERT_EQ(move(a).<a class="code" href="structstx_1_1Option.html#a7845c47770ef65233727d1fb0eb2e876">OR</a>(move(b)), Some(2));</div><div class="line"></div><div class="line">Option&lt;int&gt; c = <a class="code" href="namespacestx.html#a5cc62cda4ca89a8ebd4b9fb212fe30c4">None</a>;</div><div class="line"><a class="code" href="structstx_1_1Option.html#aded24f2b34b4e8898e0b21ab4e36b58b">Option</a> d = Some(100);</div><div class="line">ASSERT_EQ(move(c).<a class="code" href="structstx_1_1Option.html#a7845c47770ef65233727d1fb0eb2e876">OR</a>(move(d)), Some(100));</div><div class="line"></div><div class="line"><a class="code" href="structstx_1_1Option.html#aded24f2b34b4e8898e0b21ab4e36b58b">Option</a> e = Some(2);</div><div class="line"><a class="code" href="structstx_1_1Option.html#aded24f2b34b4e8898e0b21ab4e36b58b">Option</a> f = Some(100);</div><div class="line">ASSERT_EQ(move(e).<a class="code" href="structstx_1_1Option.html#a7845c47770ef65233727d1fb0eb2e876">OR</a>(move(f)), Some(2));</div><div class="line"></div><div class="line">Option&lt;int&gt; g = <a class="code" href="namespacestx.html#a5cc62cda4ca89a8ebd4b9fb212fe30c4">None</a>;</div><div class="line">Option&lt;int&gt; h = <a class="code" href="namespacestx.html#a5cc62cda4ca89a8ebd4b9fb212fe30c4">None</a>;</div><div class="line">ASSERT_EQ(move(g).<a class="code" href="structstx_1_1Option.html#a7845c47770ef65233727d1fb0eb2e876">OR</a>(move(h)), <a class="code" href="namespacestx.html#a5cc62cda4ca89a8ebd4b9fb212fe30c4">None</a>);</div></div><!-- fragment --> 
</div>
</div>
<a id="a1ef1ca63e3d4002537e19649c964ebab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ef1ca63e3d4002537e19649c964ebab">&#9670;&nbsp;</a></span>or_else()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structstx_1_1Option.html">stx::Option</a>&lt; T &gt;::or_else </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> &amp;&amp; -&gt; <a class="el" href="structstx_1_1Option.html">Option</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the option if it contains a value, otherwise calls <code>f</code> and returns the result.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> nobody = []() -&gt; Option&lt;string&gt; { <span class="keywordflow">return</span> <a class="code" href="namespacestx.html#a5cc62cda4ca89a8ebd4b9fb212fe30c4">None</a>; };</div><div class="line"><span class="keyword">auto</span> vikings = []() -&gt; Option&lt;string&gt; { <span class="keywordflow">return</span> Some(<span class="stringliteral">&quot;vikings&quot;</span>s); };</div><div class="line"></div><div class="line">ASSERT_EQ(<a class="code" href="structstx_1_1Option.html#aded24f2b34b4e8898e0b21ab4e36b58b">Option</a>(Some(<span class="stringliteral">&quot;barbarians&quot;</span>s)).<a class="code" href="structstx_1_1Option.html#a1ef1ca63e3d4002537e19649c964ebab">or_else</a>(vikings),</div><div class="line">Some(<span class="stringliteral">&quot;barbarians&quot;</span>s));</div><div class="line">ASSERT_EQ(make_none&lt;string&gt;().<a class="code" href="structstx_1_1Option.html#a1ef1ca63e3d4002537e19649c964ebab">or_else</a>(vikings), Some(<span class="stringliteral">&quot;vikings&quot;</span>s));</div><div class="line">ASSERT_EQ(make_none&lt;string&gt;().<a class="code" href="structstx_1_1Option.html#a1ef1ca63e3d4002537e19649c964ebab">or_else</a>(nobody), <a class="code" href="namespacestx.html#a5cc62cda4ca89a8ebd4b9fb212fe30c4">None</a>);</div></div><!-- fragment --> 
</div>
</div>
<a id="acd2fe0fddbd977bbb36f795d86357fb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd2fe0fddbd977bbb36f795d86357fb2">&#9670;&nbsp;</a></span>replace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structstx_1_1Option.html">stx::Option</a>&lt; T &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>replacement</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structstx_1_1Option.html">Option</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Replaces the actual value in the option by the value given in parameter, returning the old value if present, leaving a <code><a class="el" href="structstx_1_1Some.html">Some</a></code> in its place without deinitializing either one.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><a class="code" href="structstx_1_1Option.html#aded24f2b34b4e8898e0b21ab4e36b58b">Option</a> x = Some(2);</div><div class="line"><span class="keyword">auto</span> old_x = x.replace(5);</div><div class="line">ASSERT_EQ(x, Some(5));</div><div class="line">ASSERT_EQ(old_x, Some(2));</div><div class="line"></div><div class="line">Option&lt;int&gt; y = <a class="code" href="namespacestx.html#a5cc62cda4ca89a8ebd4b9fb212fe30c4">None</a>;</div><div class="line"><span class="keyword">auto</span> old_y = y.replace(3);</div><div class="line">ASSERT_EQ(y, Some(3));</div><div class="line">ASSERT_EQ(old_y, <a class="code" href="namespacestx.html#a5cc62cda4ca89a8ebd4b9fb212fe30c4">None</a>);</div></div><!-- fragment --> 
</div>
</div>
<a id="a8cefdccb8d729acf6f1c398f5a72bc65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cefdccb8d729acf6f1c398f5a72bc65">&#9670;&nbsp;</a></span>replace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structstx_1_1Option.html">stx::Option</a>&lt; T &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>replacement</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structstx_1_1Option.html">Option</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Replaces the actual value in the option by the value given in parameter, returning the old value if present, leaving a <code><a class="el" href="structstx_1_1Some.html">Some</a></code> in its place without deinitializing either one.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><a class="code" href="structstx_1_1Option.html#aded24f2b34b4e8898e0b21ab4e36b58b">Option</a> x = Some(2);</div><div class="line"><span class="keyword">auto</span> old_x = x.replace(5);</div><div class="line">ASSERT_EQ(x, Some(5));</div><div class="line">ASSERT_EQ(old_x, Some(2));</div><div class="line"></div><div class="line">Option&lt;int&gt; y = <a class="code" href="namespacestx.html#a5cc62cda4ca89a8ebd4b9fb212fe30c4">None</a>;</div><div class="line"><span class="keyword">auto</span> old_y = y.replace(3);</div><div class="line">ASSERT_EQ(y, Some(3));</div><div class="line">ASSERT_EQ(old_y, <a class="code" href="namespacestx.html#a5cc62cda4ca89a8ebd4b9fb212fe30c4">None</a>);</div></div><!-- fragment --> 
</div>
</div>
<a id="aa4df8a6637e0bfe0dd18bbbeb7caa0c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4df8a6637e0bfe0dd18bbbeb7caa0c0">&#9670;&nbsp;</a></span>take()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structstx_1_1Option.html">stx::Option</a>&lt; T &gt;::take </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="structstx_1_1Option.html">Option</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Takes the value out of the option, leaving a <code>None</code> in its place.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><a class="code" href="structstx_1_1Option.html#aded24f2b34b4e8898e0b21ab4e36b58b">Option</a> a = Some(2);</div><div class="line"><span class="keyword">auto</span> b = a.take();</div><div class="line">ASSERT_EQ(a, <a class="code" href="namespacestx.html#a5cc62cda4ca89a8ebd4b9fb212fe30c4">None</a>);</div><div class="line">ASSERT_EQ(b, Some(2));</div><div class="line"></div><div class="line">Option&lt;int&gt; c  = <a class="code" href="namespacestx.html#a5cc62cda4ca89a8ebd4b9fb212fe30c4">None</a>;</div><div class="line"><span class="keyword">auto</span> d = c.take();</div><div class="line">ASSERT_EQ(c, <a class="code" href="namespacestx.html#a5cc62cda4ca89a8ebd4b9fb212fe30c4">None</a>);</div><div class="line">ASSERT_EQ(d, <a class="code" href="namespacestx.html#a5cc62cda4ca89a8ebd4b9fb212fe30c4">None</a>);</div></div><!-- fragment --> 
</div>
</div>
<a id="ab7d8354aa8d2ae9df4d35876a5a45a41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7d8354aa8d2ae9df4d35876a5a45a41">&#9670;&nbsp;</a></span>unwrap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structstx_1_1Option.html">stx::Option</a>&lt; T &gt;::unwrap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp; -&gt; T </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Moves the value out of the <code><a class="el" href="structstx_1_1Option.html">Option</a>&lt;T&gt;</code> if it is in the variant state of <code><a class="el" href="structstx_1_1Some.html">Some</a>&lt;T&gt;</code>.</p>
<p>In general, because this function may panic, its use is discouraged. Instead, prefer to use pattern matching and handle the <code>None</code> case explicitly.</p>
<h1>Panics</h1>
<p>Panics if its value equals <code>None</code>.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><a class="code" href="structstx_1_1Option.html#aded24f2b34b4e8898e0b21ab4e36b58b">Option</a> x = Some(<span class="stringliteral">&quot;air&quot;</span>s);</div><div class="line">ASSERT_EQ(move(x).<a class="code" href="structstx_1_1Option.html#ab7d8354aa8d2ae9df4d35876a5a45a41">unwrap</a>(), <span class="stringliteral">&quot;air&quot;</span>);</div><div class="line"></div><div class="line">Option&lt;string&gt; y = <a class="code" href="namespacestx.html#a5cc62cda4ca89a8ebd4b9fb212fe30c4">None</a>;</div><div class="line">ASSERT_DEATH(move(y).<a class="code" href="structstx_1_1Option.html#ab7d8354aa8d2ae9df4d35876a5a45a41">unwrap</a>());</div></div><!-- fragment --> 
</div>
</div>
<a id="a44e064a8f29d3491ec611ea8cb035a43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44e064a8f29d3491ec611ea8cb035a43">&#9670;&nbsp;</a></span>unwrap_none()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structstx_1_1Option.html">stx::Option</a>&lt; T &gt;::unwrap_none </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unwraps an option, expecting <code>None</code> and returning nothing.</p>
<h1>Panics</h1>
<p>Panics if the value is a <code><a class="el" href="structstx_1_1Some.html">Some</a></code>.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> divide = [](<span class="keywordtype">double</span> num, <span class="keywordtype">double</span> denom) -&gt; Option&lt;double&gt; {</div><div class="line"><span class="keywordflow">if</span> (denom == 0.0) <span class="keywordflow">return</span> <a class="code" href="namespacestx.html#a5cc62cda4ca89a8ebd4b9fb212fe30c4">None</a>;</div><div class="line"> <span class="keywordflow">return</span> Some(num / denom);</div><div class="line">};</div><div class="line"></div><div class="line">ASSERT_DEATH(divide(0.0, 1.0).<a class="code" href="structstx_1_1Option.html#a44e064a8f29d3491ec611ea8cb035a43">unwrap_none</a>());</div><div class="line">ASSERT_NO_THROW(divide(1.0, 0.0).<a class="code" href="structstx_1_1Option.html#a44e064a8f29d3491ec611ea8cb035a43">unwrap_none</a>());</div></div><!-- fragment --> 
</div>
</div>
<a id="ad699fe761b32bc9e64511a5619943155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad699fe761b32bc9e64511a5619943155">&#9670;&nbsp;</a></span>unwrap_or()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structstx_1_1Option.html">stx::Option</a>&lt; T &gt;::unwrap_or </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>alt</em></td><td>)</td>
          <td> &amp;&amp; -&gt; T </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the contained value or an alternative: <code>alt</code>.</p>
<p>Arguments passed to <code>unwrap_or</code> are eagerly evaluated; if you are passing the result of a function call, it is recommended to use <code>unwrap_or_else</code>, which is lazily evaluated.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line">ASSERT_EQ(<a class="code" href="structstx_1_1Option.html#aded24f2b34b4e8898e0b21ab4e36b58b">Option</a>(Some(<span class="stringliteral">&quot;car&quot;</span>s)).<a class="code" href="structstx_1_1Option.html#ad699fe761b32bc9e64511a5619943155">unwrap_or</a>(<span class="stringliteral">&quot;bike&quot;</span>), <span class="stringliteral">&quot;car&quot;</span>);</div><div class="line">ASSERT_EQ(make_none&lt;string&gt;().<a class="code" href="structstx_1_1Option.html#ad699fe761b32bc9e64511a5619943155">unwrap_or</a>(<span class="stringliteral">&quot;bike&quot;</span>), <span class="stringliteral">&quot;bike&quot;</span>);</div></div><!-- fragment --> 
</div>
</div>
<a id="aa1a001d634820489d482b97d498a5fcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1a001d634820489d482b97d498a5fcc">&#9670;&nbsp;</a></span>unwrap_or_default()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structstx_1_1Option.html">stx::Option</a>&lt; T &gt;::unwrap_or_default </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp; -&gt; T </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the contained value or a default of T</p>
<p>Consumes this object and returns its <code><a class="el" href="structstx_1_1Some.html">Some</a>&lt;T&gt;</code> value if it is a <code><a class="el" href="structstx_1_1Some.html">Some</a>&lt;T&gt;</code> variant, else if this object is a <code>None</code> variant, returns the default of the value type <code>T</code>.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><a class="code" href="structstx_1_1Option.html#aded24f2b34b4e8898e0b21ab4e36b58b">Option</a> x = Some(<span class="stringliteral">&quot;Ten&quot;</span>s);</div><div class="line">Option&lt;string&gt; y = <a class="code" href="namespacestx.html#a5cc62cda4ca89a8ebd4b9fb212fe30c4">None</a>;</div><div class="line"></div><div class="line">ASSERT_EQ(move(x).<a class="code" href="structstx_1_1Option.html#aa1a001d634820489d482b97d498a5fcc">unwrap_or_default</a>(), <span class="stringliteral">&quot;Ten&quot;</span>s);</div><div class="line">ASSERT_EQ(move(y).<a class="code" href="structstx_1_1Option.html#aa1a001d634820489d482b97d498a5fcc">unwrap_or_default</a>(), <span class="stringliteral">&quot;&quot;</span>s);</div></div><!-- fragment --> 
</div>
</div>
<a id="aa09fe2bc72fc2a4bdfac321c70449625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa09fe2bc72fc2a4bdfac321c70449625">&#9670;&nbsp;</a></span>unwrap_or_else()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structstx_1_1Option.html">stx::Option</a>&lt; T &gt;::unwrap_or_else </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> &amp;&amp; -&gt; T </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the contained value or computes it from a function.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> k = 10;</div><div class="line"><span class="keyword">auto</span> alt = [&amp;k]() { <span class="keywordflow">return</span> 2 * k; };</div><div class="line"></div><div class="line">ASSERT_EQ(<a class="code" href="namespacestx.html#af3dd9531b7d03154feb5ab0b5230cd84">make_some</a>(4).<a class="code" href="structstx_1_1Option.html#aa09fe2bc72fc2a4bdfac321c70449625">unwrap_or_else</a>(alt), 4);</div><div class="line">ASSERT_EQ(make_none&lt;int&gt;().<a class="code" href="structstx_1_1Option.html#aa09fe2bc72fc2a4bdfac321c70449625">unwrap_or_else</a>(alt), 20);</div></div><!-- fragment --> 
</div>
</div>
<a id="a1a4235a790f4a64af1877ec8fd85668d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a4235a790f4a64af1877ec8fd85668d">&#9670;&nbsp;</a></span>value() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="structstx_1_1Option.html">stx::Option</a>&lt; T &gt;::value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an l-value reference to the contained value. Note that no copying occurs here.</p>
<h1>Panics</h1>
<p>Panics if the value is a <code>None</code></p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> x = <a class="code" href="namespacestx.html#af3dd9531b7d03154feb5ab0b5230cd84">make_some</a>(9);</div><div class="line"><span class="keywordtype">int</span>&amp; y = x.value();</div><div class="line">y = 2;</div><div class="line"></div><div class="line">ASSERT_EQ(x, Some(2));</div></div><!-- fragment --> 
</div>
</div>
<a id="ad34cb398d371752ccda7a7d1365c612a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad34cb398d371752ccda7a7d1365c612a">&#9670;&nbsp;</a></span>value() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T const&amp; <a class="el" href="structstx_1_1Option.html">stx::Option</a>&lt; T &gt;::value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a const l-value reference to the contained value. Note that no copying occurs here.</p>
<h1>Panics</h1>
<p>Panics if the value is a <code>None</code></p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> <span class="keyword">const</span> x = <a class="code" href="namespacestx.html#af3dd9531b7d03154feb5ab0b5230cd84">make_some</a>(9);</div><div class="line"><span class="keywordtype">int</span> <span class="keyword">const</span>&amp; y = x.value();</div><div class="line"></div><div class="line">ASSERT_EQ(y, 9);</div></div><!-- fragment --> 
</div>
</div>
<a id="a050734af1cb048d3ac2d590be377a273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a050734af1cb048d3ac2d590be377a273">&#9670;&nbsp;</a></span>value() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="structstx_1_1Option.html">stx::Option</a>&lt; T &gt;::value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use <code><a class="el" href="structstx_1_1Option.html#ab7d8354aa8d2ae9df4d35876a5a45a41">unwrap()</a></code> instead. </p>

</div>
</div>
<a id="a12035d3b7bc6158c4bf4a291f866fb0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12035d3b7bc6158c4bf4a291f866fb0b">&#9670;&nbsp;</a></span>value() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T const <a class="el" href="structstx_1_1Option.html">stx::Option</a>&lt; T &gt;::value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use <code><a class="el" href="structstx_1_1Option.html#ab7d8354aa8d2ae9df4d35876a5a45a41">unwrap()</a></code> instead. </p>

</div>
</div>
<a id="a93ab884632f021c095f5a64ebc14b54d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93ab884632f021c095f5a64ebc14b54d">&#9670;&nbsp;</a></span>XOR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structstx_1_1Option.html">stx::Option</a>&lt; T &gt;::XOR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1Option.html">Option</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>alt</em></td><td>)</td>
          <td> &amp;&amp; -&gt; <a class="el" href="structstx_1_1Option.html">Option</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whichever one of this object or <code>alt</code> is a <code><a class="el" href="structstx_1_1Some.html">Some</a>&lt;T&gt;</code> variant, otherwise returns <code>None</code> if neither or both are a <code><a class="el" href="structstx_1_1Some.html">Some</a>&lt;T&gt;</code> variant.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><a class="code" href="structstx_1_1Option.html#aded24f2b34b4e8898e0b21ab4e36b58b">Option</a> a = Some(2);</div><div class="line">Option&lt;int&gt; b = <a class="code" href="namespacestx.html#a5cc62cda4ca89a8ebd4b9fb212fe30c4">None</a>;</div><div class="line">ASSERT_EQ(move(a).<a class="code" href="structstx_1_1Option.html#a93ab884632f021c095f5a64ebc14b54d">XOR</a>(move(b)), Some(2));</div><div class="line"></div><div class="line">Option&lt;int&gt; c = <a class="code" href="namespacestx.html#a5cc62cda4ca89a8ebd4b9fb212fe30c4">None</a>;</div><div class="line"><a class="code" href="structstx_1_1Option.html#aded24f2b34b4e8898e0b21ab4e36b58b">Option</a> d = Some(2);</div><div class="line">ASSERT_EQ(move(c).<a class="code" href="structstx_1_1Option.html#a93ab884632f021c095f5a64ebc14b54d">XOR</a>(move(d)), Some(2));</div><div class="line"></div><div class="line"><a class="code" href="structstx_1_1Option.html#aded24f2b34b4e8898e0b21ab4e36b58b">Option</a> e = Some(2);</div><div class="line"><a class="code" href="structstx_1_1Option.html#aded24f2b34b4e8898e0b21ab4e36b58b">Option</a> f = Some(2);</div><div class="line">ASSERT_EQ(move(e).<a class="code" href="structstx_1_1Option.html#a93ab884632f021c095f5a64ebc14b54d">XOR</a>(move(f)), <a class="code" href="namespacestx.html#a5cc62cda4ca89a8ebd4b9fb212fe30c4">None</a>);</div><div class="line"></div><div class="line">Option&lt;int&gt; g = <a class="code" href="namespacestx.html#a5cc62cda4ca89a8ebd4b9fb212fe30c4">None</a>;</div><div class="line">Option&lt;int&gt; h = <a class="code" href="namespacestx.html#a5cc62cda4ca89a8ebd4b9fb212fe30c4">None</a>;</div><div class="line">ASSERT_EQ(move(g).<a class="code" href="structstx_1_1Option.html#a93ab884632f021c095f5a64ebc14b54d">XOR</a>(move(h)), <a class="code" href="namespacestx.html#a5cc62cda4ca89a8ebd4b9fb212fe30c4">None</a>);</div></div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a58c3f73a123e4a5f64cfc16a937d8175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58c3f73a123e4a5f64cfc16a937d8175">&#9670;&nbsp;</a></span>internal::option::unsafe_value_move</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Tp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Tp&amp;&amp; <a class="el" href="namespacestx_1_1internal_1_1option.html#ac4357cf95caeaf6ed23a0ed3ad62e156">internal::option::unsafe_value_move</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1Option.html">Option</a>&lt; Tp &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ab1498e91710137969923d0f2931a2093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1498e91710137969923d0f2931a2093">&#9670;&nbsp;</a></span>storage_value_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="structstx_1_1Option.html">stx::Option</a>&lt; T &gt;::storage_value_</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>include/stx/internal/<a class="el" href="option__result_8h_source.html">option_result.h</a></li>
</ul>
<div class="dynheader">
Inheritance diagram for stx::Option&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="structstx_1_1Option__inherit__graph.png" border="0" usemap="#stx_1_1Option_3_01T_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="stx_1_1Option_3_01T_01_4_inherit__map" id="stx_1_1Option_3_01T_01_4_inherit__map">
<area shape="rect" id="node2" href="structstx_1_1Option.html" title="stx::Option\&lt; stx::backtrace\l::Symbol \&gt;" alt="" coords="5,95,205,136"/>
<area shape="rect" id="node3" href="structstx_1_1Option.html" title="stx::Option\&lt; uintptr_t \&gt;" alt="" coords="231,102,409,129"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer" />
<address class="footer"><small>
    Generated by &#160;<a href="http://www.doxygen.org/index.html"> Doxygen
    </a> 1.8.13
  </small></address>
<script type="text/javascript">
  (() => {
    document.body.onload = (() => {
      //
      //
      let clipboard_icon = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"\
      class="copy-icon dimming-wrap">\
      <path d="M0 0h24v24H0z"  fill="none"/>\
      <path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 \
      2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/>\
      </svg>';
      for (let x of document.querySelectorAll("div.fragment")) {
        if (x.querySelector(".lineno") == null)
          x.innerHTML = clipboard_icon + x.innerHTML;
      };
      for (let copy_icon of document.querySelectorAll(".copy-icon")) {
        copy_icon.onclick = () => {
          let code_content = "";
          for (let line of copy_icon.parentElement.querySelectorAll(".line")) {
            code_content = code_content.concat(line.textContent);
            code_content = code_content.concat("\n");
          }
          navigator.clipboard.writeText(code_content);
          alert("Copied to Clipboard");
        };
      };
    });
  })();
</script>
</body>
</html>