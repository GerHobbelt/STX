<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=9" />
    <meta name="generator" content="Doxygen 1.8.13" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>STX: stx::Option&lt; T &gt; Class Template Reference</title>
    <link href="tabs.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <link href="styles.css" rel="stylesheet" type="text/css" />
</head>
<body>
    <script>
        /*
                // light mode, dark mode
                color: ["#333", "#DDD"],
                backgroundColor: ["#FFFFFF", "#353535"],
                cardBackgroundColor: ["#F5F5F5", "#2A2A2A"],
                linkColor: ["#3D578C", "#D2991D"],
                headerBackgroundColor: ["#F1F1F1", "#505050"],
                headerHoverBackgroundColor: ["#F5F5F5", "#444"],
                // memtitle, memproto, memitemleft, memitemright 
                docprotoBackgroundColor: ["#FAFAFA", "2A2A2A"]
        */
        function switchTheme() {
            let theme = localStorage.getItem("theme");
            if (theme == "light" || theme == null) {
                document.body.className = "dark-theme";
                localStorage.setItem("theme", "dark");
            } else {
                document.body.className = "";
                localStorage.setItem("theme", "light");
            }
        }
        (function loadTheme() {
            let theme = localStorage.getItem("theme");
            console.log("theme:" + theme);
            if (theme == "light" || theme == null) {
                document.body.className = "";
            } else {
                document.body.className = "dark-theme";
            }
        })();
    </script>
    <div class="theme-switch dimming-wrap" onclick="switchTheme()">
        <div>
            <svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 48 48">
                <path
                    d="M42 6H6c-2.21 0-4 1.79-4 4v28c0 2.21 1.79 4 4 4h36c2.21 0 4-1.79 4-4V10c0-2.21-1.79-4-4-4zm0 32.03H6V9.97h36v28.06zM16 32h5l3 3 3-3h5v-5l3-3-3-3v-5h-5l-3-3-3 3h-5v5l-3 3 3 3v5zm8-14c3.31 0 6 2.69 6 6s-2.69 6-6 6V18z" />
            </svg></div>
    </div>
    <div id="top">
        <!-- do not remove this div, it is closed by doxygen! -->
        <div id="titlearea">
            <table cellspacing="0" cellpadding="0">
                <tbody>
                    <tr style="height: 56px;">
                        <td id="projectlogo"><img alt="Logo"
                                src="eagle.png" /></td>
                        <td id="projectalign" style="padding-left: 0.5em;">
                            <div id="projectname"> STX
                            </div>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
        <!-- end header part --><!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacestx.html">stx</a></li><li class="navelem"><a class="el" href="classstx_1_1Option.html">Option</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classstx_1_1Option-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">stx::Option&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="option__result_8h_source.html">option_result.h</a>&gt;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;Swappable T&gt;<br />
class stx::Option&lt; T &gt;</h3>

<p>Optional values.</p>
<p>Type <code><a class="el" href="classstx_1_1Option.html">Option</a></code> represents an optional value: every <code><a class="el" href="classstx_1_1Option.html">Option</a></code> is either <code><a class="el" href="structstx_1_1Some.html">Some</a></code> and contains a value, or <code>None</code>, and does not. They have a number of uses:</p>
<ul>
<li>Initial values</li>
<li>Return values for functions that are not defined over their entire input range (partial functions)</li>
<li>Return value for otherwise reporting simple errors, where <code>None</code> is returned on error</li>
<li>Optional struct fields</li>
<li>Struct fields that can be loaned or "taken"</li>
<li>Optional function arguments</li>
<li>Nullable pointers</li>
<li>Swapping things out of difficult situations</li>
</ul>
<p><code><a class="el" href="classstx_1_1Option.html">Option</a></code>'s are commonly paired with pattern matching to query the presence of a value and take action, always accounting for the <code>None</code>s case.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> divide = [](<span class="keywordtype">double</span> numerator, <span class="keywordtype">double</span> denominator) -&gt; Option&lt;double&gt; {</div><div class="line">  <span class="keywordflow">if</span> (denominator == 0.0) {</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="namespacestx.html#a9ba8a760ec020ea9b105ae6060494203">None</a>;</div><div class="line">  } <span class="keywordflow">else</span> {</div><div class="line">    <span class="keywordflow">return</span> Some(numerator / denominator);</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// The return value of the function is an option</span></div><div class="line"><span class="keyword">auto</span> result = divide(2.0, 3.0);</div><div class="line">move(result).match([](<span class="keywordtype">double</span> <a class="code" href="classstx_1_1Option.html#a1a4235a790f4a64af1877ec8fd85668d">value</a>) { fmt::print(<span class="stringliteral">&quot;{}\n&quot;</span>, value); },</div><div class="line">                    []() { fmt::print(<span class="stringliteral">&quot;has no value&quot;</span>); });</div></div><!-- fragment --> </div><div class="dynheader">
Collaboration diagram for stx::Option&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classstx_1_1Option__coll__graph.png" border="0" usemap="#stx_1_1Option_3_01T_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="stx_1_1Option_3_01T_01_4_coll__map" id="stx_1_1Option_3_01T_01_4_coll__map">
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aeaa044f1723c0cc20cb7690d8fe4e490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaa044f1723c0cc20cb7690d8fe4e490">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classstx_1_1Option.html">stx::Option</a>&lt; T &gt;::<a class="el" href="classstx_1_1Option.html#aeaa044f1723c0cc20cb7690d8fe4e490">value_type</a> =  T</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4932534a2ba009b62edbd0fd7125cc47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4932534a2ba009b62edbd0fd7125cc47">&#9670;&nbsp;</a></span>Option() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classstx_1_1Option.html">stx::Option</a>&lt; T &gt;::<a class="el" href="classstx_1_1Option.html">Option</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1Some.html">Some</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>some</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad8f98364c4756f781e95125945001d7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8f98364c4756f781e95125945001d7b">&#9670;&nbsp;</a></span>Option() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classstx_1_1Option.html">stx::Option</a>&lt; T &gt;::<a class="el" href="classstx_1_1Option.html">Option</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstx_1_1NoneType.html">NoneType</a> const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5a0a5aba40a4e482ab05c805dd96eee6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a0a5aba40a4e482ab05c805dd96eee6">&#9670;&nbsp;</a></span>Option() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstx_1_1Option.html">stx::Option</a>&lt; T &gt;::<a class="el" href="classstx_1_1Option.html">Option</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstx_1_1Option.html">Option</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9393450b154680722566eef0236a7765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9393450b154680722566eef0236a7765">&#9670;&nbsp;</a></span>Option() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classstx_1_1Option.html">stx::Option</a>&lt; T &gt;::<a class="el" href="classstx_1_1Option.html">Option</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5603f2ed9c7a9254ae6cf607dd7c4bfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5603f2ed9c7a9254ae6cf607dd7c4bfc">&#9670;&nbsp;</a></span>Option() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classstx_1_1Option.html">stx::Option</a>&lt; T &gt;::<a class="el" href="classstx_1_1Option.html">Option</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstx_1_1Option.html">Option</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae971f931e63812e5fe71b4b2620ca5a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae971f931e63812e5fe71b4b2620ca5a6">&#9670;&nbsp;</a></span>~Option()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classstx_1_1Option.html">stx::Option</a>&lt; T &gt;::~<a class="el" href="classstx_1_1Option.html">Option</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7fe69cb81556133f27e53851753578ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fe69cb81556133f27e53851753578ed">&#9670;&nbsp;</a></span>AND()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classstx_1_1Option.html">stx::Option</a>&lt; T &gt;::AND </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstx_1_1Option.html">Option</a>&lt; U &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>cmp</em></td><td>)</td>
          <td> &amp;&amp; -&gt; <a class="el" href="classstx_1_1Option.html">Option</a>&lt;U&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <code>None</code> if the option is <code>None</code>, otherwise returns <code>cmp</code>.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><a class="code" href="classstx_1_1Option.html#a9393450b154680722566eef0236a7765">Option</a> a = Some(2);</div><div class="line">Option&lt;string&gt; b = <a class="code" href="namespacestx.html#a9ba8a760ec020ea9b105ae6060494203">None</a>;</div><div class="line">ASSERT_EQ(move(a).<a class="code" href="classstx_1_1Option.html#a7fe69cb81556133f27e53851753578ed">AND</a>(move(b)), <a class="code" href="namespacestx.html#a9ba8a760ec020ea9b105ae6060494203">None</a>);</div><div class="line"></div><div class="line">Option&lt;int&gt; c = <a class="code" href="namespacestx.html#a9ba8a760ec020ea9b105ae6060494203">None</a>;</div><div class="line"><a class="code" href="classstx_1_1Option.html#a9393450b154680722566eef0236a7765">Option</a> d = Some(<span class="stringliteral">&quot;foo&quot;</span>s);</div><div class="line">ASSERT_EQ(move(c).<a class="code" href="classstx_1_1Option.html#a7fe69cb81556133f27e53851753578ed">AND</a>(move(d)), <a class="code" href="namespacestx.html#a9ba8a760ec020ea9b105ae6060494203">None</a>);</div><div class="line"></div><div class="line"><a class="code" href="classstx_1_1Option.html#a9393450b154680722566eef0236a7765">Option</a> e = Some(2);</div><div class="line"><a class="code" href="classstx_1_1Option.html#a9393450b154680722566eef0236a7765">Option</a> f = Some(<span class="stringliteral">&quot;foo&quot;</span>s);</div><div class="line">ASSERT_EQ(move(e).<a class="code" href="classstx_1_1Option.html#a7fe69cb81556133f27e53851753578ed">AND</a>(move(f)), Some(<span class="stringliteral">&quot;foo&quot;</span>s));</div><div class="line"></div><div class="line">Option&lt;int&gt; g = <a class="code" href="namespacestx.html#a9ba8a760ec020ea9b105ae6060494203">None</a>;</div><div class="line">Option&lt;string&gt; h = <a class="code" href="namespacestx.html#a9ba8a760ec020ea9b105ae6060494203">None</a>;</div><div class="line">ASSERT_EQ(move(g).<a class="code" href="classstx_1_1Option.html#a7fe69cb81556133f27e53851753578ed">AND</a>(move(h)), <a class="code" href="namespacestx.html#a9ba8a760ec020ea9b105ae6060494203">None</a>);</div></div><!-- fragment --> 
</div>
</div>
<a id="a169ed0965ab0e3486db4b8f6a76e6ee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a169ed0965ab0e3486db4b8f6a76e6ee4">&#9670;&nbsp;</a></span>and_then()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T&gt; </div>
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">requires <a class="el" href="namespacestx.html#aa8f14c3c14e6dcdecfdf0710ee2ed774">invocable</a>&lt;Fn&amp;&amp;, T&amp;&amp;&gt; [[nodiscard]] constexpr auto <a class="el" href="classstx_1_1Option.html">stx::Option</a>&lt; T &gt;::and_then </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> &amp;&amp; -&gt; <a class="el" href="namespacestx.html#ac43d924d52c43f451ac8f9a9ae00934b">invoke_result</a>&lt;Fn&amp;&amp;, T&amp;&amp;&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <code>None</code> if the option is <code>None</code>, otherwise calls <code>op</code> with the wrapped value and returns the result.</p>
<p><a class="el" href="structstx_1_1Some.html">Some</a> languages call this operation flatmap.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> sq = [] (<span class="keyword">auto</span> x) -&gt; Option&lt;int&gt; { <span class="keywordflow">return</span> Some(x * x); };</div><div class="line"><span class="keyword">auto</span> nope = [] (<span class="keyword">auto</span>) -&gt; Option&lt;int&gt; { <span class="keywordflow">return</span> <a class="code" href="namespacestx.html#a9ba8a760ec020ea9b105ae6060494203">None</a>; };</div><div class="line"></div><div class="line">ASSERT_EQ(<a class="code" href="namespacestx.html#af3dd9531b7d03154feb5ab0b5230cd84">make_some</a>(2).<a class="code" href="classstx_1_1Option.html#a169ed0965ab0e3486db4b8f6a76e6ee4">and_then</a>(sq).<a class="code" href="classstx_1_1Option.html#a169ed0965ab0e3486db4b8f6a76e6ee4">and_then</a>(sq), Some(16));</div><div class="line">ASSERT_EQ(<a class="code" href="namespacestx.html#af3dd9531b7d03154feb5ab0b5230cd84">make_some</a>(2).<a class="code" href="classstx_1_1Option.html#a169ed0965ab0e3486db4b8f6a76e6ee4">and_then</a>(sq).<a class="code" href="classstx_1_1Option.html#a169ed0965ab0e3486db4b8f6a76e6ee4">and_then</a>(nope), <a class="code" href="namespacestx.html#a9ba8a760ec020ea9b105ae6060494203">None</a>);</div><div class="line">ASSERT_EQ(<a class="code" href="namespacestx.html#af3dd9531b7d03154feb5ab0b5230cd84">make_some</a>(2).<a class="code" href="classstx_1_1Option.html#a169ed0965ab0e3486db4b8f6a76e6ee4">and_then</a>(nope).<a class="code" href="classstx_1_1Option.html#a169ed0965ab0e3486db4b8f6a76e6ee4">and_then</a>(sq), <a class="code" href="namespacestx.html#a9ba8a760ec020ea9b105ae6060494203">None</a>);</div><div class="line">ASSERT_EQ(make_none&lt;int&gt;().<a class="code" href="classstx_1_1Option.html#a169ed0965ab0e3486db4b8f6a76e6ee4">and_then</a>(sq).<a class="code" href="classstx_1_1Option.html#a169ed0965ab0e3486db4b8f6a76e6ee4">and_then</a>(sq), <a class="code" href="namespacestx.html#a9ba8a760ec020ea9b105ae6060494203">None</a>);</div></div><!-- fragment --> 
</div>
</div>
<a id="a19a726a6be4a76f61ae9aad84740a5af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19a726a6be4a76f61ae9aad84740a5af">&#9670;&nbsp;</a></span>as_const_deref() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classstx_1_1Option.html">stx::Option</a>&lt; T &gt;::as_const_deref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dereferences the pointer or iterator, therefore returning a const reference to the pointed-to value (<code><a class="el" href="classstx_1_1Option.html">Option</a>&lt;ConstRef&lt;V&gt;&gt;</code>).</p>
<p>Leaves the original <a class="el" href="classstx_1_1Option.html">Option</a> in-place, creating a new one with an l-value reference to the original one.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> str = <span class="stringliteral">&quot;Hello&quot;</span>s;</div><div class="line"><a class="code" href="classstx_1_1Option.html#a9393450b154680722566eef0236a7765">Option</a> x = Some(&amp;str);</div><div class="line">ASSERT_EQ(x.as_const_deref().unwrap().get(), <span class="stringliteral">&quot;Hello&quot;</span>s);</div><div class="line"></div><div class="line">Option&lt;string*&gt; y = <a class="code" href="namespacestx.html#a9ba8a760ec020ea9b105ae6060494203">None</a>;</div><div class="line">ASSERT_EQ(y.as_const_deref(), <a class="code" href="namespacestx.html#a9ba8a760ec020ea9b105ae6060494203">None</a>);</div></div><!-- fragment --> 
</div>
</div>
<a id="a7c352e5fecc63cc62d0a72dbbb62159c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c352e5fecc63cc62d0a72dbbb62159c">&#9670;&nbsp;</a></span>as_const_deref() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classstx_1_1Option.html">stx::Option</a>&lt; T &gt;::as_const_deref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac492a01977739952ae35a3993bcc26bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac492a01977739952ae35a3993bcc26bf">&#9670;&nbsp;</a></span>as_cref() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classstx_1_1Option.html">stx::Option</a>&lt; T &gt;::as_cref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp; -&gt; <a class="el" href="classstx_1_1Option.html">Option</a>&lt;<a class="el" href="namespacestx.html#a910046924ff264eb1eec0707011908ee">ConstRef</a>&lt;T&gt;&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts from <code><a class="el" href="classstx_1_1Option.html">Option</a>&lt;T&gt; const&amp;</code> or <code><a class="el" href="classstx_1_1Option.html">Option</a>&lt;T&gt; &amp;</code> to <code><a class="el" href="classstx_1_1Option.html">Option</a>&lt;ConstRef&lt;T&gt;&gt;</code>.</p>
<h1>NOTE</h1>
<p><code>ConstRef&lt;T&gt;</code> is an alias for <code>std::reference_wrapper&lt;T const&gt;</code> and guides against reference-collapsing </p>

</div>
</div>
<a id="ad95fba7ff6153367aa973dc5f407b994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad95fba7ff6153367aa973dc5f407b994">&#9670;&nbsp;</a></span>as_cref() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classstx_1_1Option.html">stx::Option</a>&lt; T &gt;::as_cref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;&amp; -&gt;  <a class="el" href="classstx_1_1Option.html">Option</a>&lt; <a class="el" href="namespacestx.html#a910046924ff264eb1eec0707011908ee">ConstRef</a>&lt; T &gt;&gt;=delete</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a52f4c48180203391309efa07fd7793a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52f4c48180203391309efa07fd7793a4">&#9670;&nbsp;</a></span>as_mut_deref() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classstx_1_1Option.html">stx::Option</a>&lt; T &gt;::as_mut_deref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dereferences the pointer or iterator, therefore returning a mutable reference to the pointed-to value (<code><a class="el" href="classstx_1_1Option.html">Option</a>&lt;MutRef&lt;V&gt;&gt;</code>).</p>
<p>Leaves the original <code><a class="el" href="classstx_1_1Option.html">Option</a></code> in-place, creating a new one containing a mutable reference to the inner pointer's dereference value type.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> str = <span class="stringliteral">&quot;Hello&quot;</span>s;</div><div class="line"><a class="code" href="classstx_1_1Option.html#a9393450b154680722566eef0236a7765">Option</a> x = Some(&amp;str);</div><div class="line">x.as_mut_deref().unwrap().get() = <span class="stringliteral">&quot;World&quot;</span>s;</div><div class="line"></div><div class="line">ASSERT_EQ(str, <span class="stringliteral">&quot;World&quot;</span>s);</div><div class="line"></div><div class="line">Option&lt;string*&gt; z = <a class="code" href="namespacestx.html#a9ba8a760ec020ea9b105ae6060494203">None</a>;</div><div class="line">ASSERT_EQ(z.as_mut_deref(), <a class="code" href="namespacestx.html#a9ba8a760ec020ea9b105ae6060494203">None</a>);</div></div><!-- fragment --> 
</div>
</div>
<a id="a8aa7a1a80afe3ba9f438defbb180e4b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aa7a1a80afe3ba9f438defbb180e4b7">&#9670;&nbsp;</a></span>as_mut_deref() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classstx_1_1Option.html">stx::Option</a>&lt; T &gt;::as_mut_deref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a524916040d1ee38604a7e5c4b849aa67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a524916040d1ee38604a7e5c4b849aa67">&#9670;&nbsp;</a></span>as_ref() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classstx_1_1Option.html">stx::Option</a>&lt; T &gt;::as_ref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp; -&gt; <a class="el" href="classstx_1_1Option.html">Option</a>&lt;<a class="el" href="namespacestx.html#a1b55420e0cd6b42317f23d32831d1637">MutRef</a>&lt;T&gt;&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts from <code><a class="el" href="classstx_1_1Option.html">Option</a>&lt;T&gt;</code> to <code><a class="el" href="classstx_1_1Option.html">Option</a>&lt;MutRef&lt;T&gt;&gt;</code>.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> mutate = [](Option&lt;int&gt;&amp; r) {</div><div class="line"> r.as_ref().match([](MutRef&lt;int&gt; ref) { ref.get() = 42; },</div><div class="line">                      []() { });</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">auto</span> x = <a class="code" href="namespacestx.html#af3dd9531b7d03154feb5ab0b5230cd84">make_some</a>(2);</div><div class="line">mutate(x);</div><div class="line">ASSERT_EQ(x, Some(42));</div><div class="line"></div><div class="line"><span class="keyword">auto</span> y = make_none&lt;int&gt;();</div><div class="line">mutate(y);</div><div class="line">ASSERT_EQ(y, <a class="code" href="namespacestx.html#a9ba8a760ec020ea9b105ae6060494203">None</a>);</div></div><!-- fragment --> 
</div>
</div>
<a id="a9e7d17c0bc0ac77d392f29b6c417b568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e7d17c0bc0ac77d392f29b6c417b568">&#9670;&nbsp;</a></span>as_ref() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classstx_1_1Option.html">stx::Option</a>&lt; T &gt;::as_ref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp; -&gt;  <a class="el" href="classstx_1_1Option.html">Option</a>&lt; <a class="el" href="namespacestx.html#a1b55420e0cd6b42317f23d32831d1637">MutRef</a>&lt; T &gt;&gt;=delete</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a16d508c2ae207eb559f44f86da5dc9b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16d508c2ae207eb559f44f86da5dc9b4">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classstx_1_1Option.html">stx::Option</a>&lt; T &gt;::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classstx_1_1Option.html">Option</a>
      requires <a class="el" href="namespacestx.html#ac27784f661f2d1e57b357110b69ec260">copy_constructible</a>&lt;T&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a copy of the option and its contents.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><a class="code" href="classstx_1_1Option.html#a9393450b154680722566eef0236a7765">Option</a> x  = Some(8);</div><div class="line"></div><div class="line">ASSERT_EQ(x, x.clone());</div></div><!-- fragment --> 
</div>
</div>
<a id="aba38eb3c20aae53fa3890c8b44907442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba38eb3c20aae53fa3890c8b44907442">&#9670;&nbsp;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T&gt; </div>
<div class="memtemplate">
template&lt;typename CmpType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">requires <a class="el" href="namespacestx.html#a81068b2d8a2b022352d7695cf90d733b">equality_comparable</a>&lt;CmpType const&amp;, T const&amp;&gt; [[nodiscard]] constexpr bool <a class="el" href="classstx_1_1Option.html">stx::Option</a>&lt; T &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">CmpType const &amp;&#160;</td>
          <td class="paramname"><em>cmp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <code>true</code> if the option is a <code><a class="el" href="structstx_1_1Some.html">Some</a></code> value containing the given value.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><a class="code" href="classstx_1_1Option.html#a9393450b154680722566eef0236a7765">Option</a> x = Some(2);</div><div class="line">ASSERT_TRUE(x.contains(2));</div><div class="line"></div><div class="line"><a class="code" href="classstx_1_1Option.html#a9393450b154680722566eef0236a7765">Option</a> y = Some(3);</div><div class="line">ASSERT_FALSE(y.contains(2));</div><div class="line"></div><div class="line">Option&lt;int&gt; z = <a class="code" href="namespacestx.html#a9ba8a760ec020ea9b105ae6060494203">None</a>;</div><div class="line">ASSERT_FALSE(z.contains(2));</div></div><!-- fragment --> 
</div>
</div>
<a id="a264d88ed5186ae13c64a2af688e66fcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a264d88ed5186ae13c64a2af688e66fcb">&#9670;&nbsp;</a></span>exists()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T&gt; </div>
<div class="memtemplate">
template&lt;typename UnaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">requires <a class="el" href="namespacestx.html#aa8f14c3c14e6dcdecfdf0710ee2ed774">invocable</a>&lt;UnaryPredicate&amp;&amp;, T const&amp;&gt;&amp;&amp; <a class="el" href="namespacestx.html#aa0bd2b8f4938c62598f62d340bd74008">convertible_to</a>&lt;<a class="el" href="namespacestx.html#ac43d924d52c43f451ac8f9a9ae00934b">invoke_result</a>&lt;UnaryPredicate&amp;&amp;, T const&amp;&gt;, bool&gt; [[nodiscard]] constexpr bool <a class="el" href="classstx_1_1Option.html">stx::Option</a>&lt; T &gt;::exists </td>
          <td>(</td>
          <td class="paramtype">UnaryPredicate &amp;&amp;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the value of evaluating the <code>predicate</code> on the contained value if the <code><a class="el" href="classstx_1_1Option.html">Option</a></code> is a <code><a class="el" href="structstx_1_1Some.html">Some</a></code>, else returns <code>false</code>.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><a class="code" href="classstx_1_1Option.html#a9393450b154680722566eef0236a7765">Option</a> x = Some(2);</div><div class="line"><span class="keyword">auto</span> even = [](<span class="keyword">auto</span> x) { <span class="keywordflow">return</span> x == 2; };</div><div class="line">ASSERT_TRUE(x.exists(even));</div></div><!-- fragment --> 
</div>
</div>
<a id="a80895a96e6ff5ebacb1a7cf208aaa01e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80895a96e6ff5ebacb1a7cf208aaa01e">&#9670;&nbsp;</a></span>expect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classstx_1_1Option.html">stx::Option</a>&lt; T &gt;::expect </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td> &amp;&amp; -&gt; T </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unwraps an option, yielding the content of a <code><a class="el" href="structstx_1_1Some.html">Some</a></code>.</p>
<h1>Panics</h1>
<p>Panics if the value is a <code>None</code> with a custom panic message provided by <code>msg</code>.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><a class="code" href="classstx_1_1Option.html#a9393450b154680722566eef0236a7765">Option</a> x = Some(<span class="stringliteral">&quot;value&quot;</span>s);</div><div class="line">ASSERT_EQ(move(x).<a class="code" href="classstx_1_1Option.html#a80895a96e6ff5ebacb1a7cf208aaa01e">expect</a>(<span class="stringliteral">&quot;the world is ending&quot;</span>), <span class="stringliteral">&quot;value&quot;</span>);</div><div class="line"></div><div class="line">Option&lt;string&gt; y = <a class="code" href="namespacestx.html#a9ba8a760ec020ea9b105ae6060494203">None</a>;</div><div class="line">ASSERT_ANY_THROW(move(y).<a class="code" href="classstx_1_1Option.html#a80895a96e6ff5ebacb1a7cf208aaa01e">expect</a>(<span class="stringliteral">&quot;the world is ending&quot;</span>)); <span class="comment">// panics with</span></div><div class="line">                                                         <span class="comment">// the world is</span></div><div class="line">                                                         <span class="comment">// ending</span></div></div><!-- fragment --> 
</div>
</div>
<a id="aca4ecfffb340613fb8e00b0fb0189c72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca4ecfffb340613fb8e00b0fb0189c72">&#9670;&nbsp;</a></span>expect_none()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstx_1_1Option.html">stx::Option</a>&lt; T &gt;::expect_none </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unwraps an option, expecting <code>None</code> and returning nothing.</p>
<h1>Panics</h1>
<p>Panics if the value is a <code><a class="el" href="structstx_1_1Some.html">Some</a></code>, with a panic message including the passed message, and the content of the <code><a class="el" href="structstx_1_1Some.html">Some</a></code>.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> divide = [](<span class="keywordtype">double</span> num, <span class="keywordtype">double</span> denom) -&gt; Option&lt;double&gt; {</div><div class="line"><span class="keywordflow">if</span> (denom == 0.0) <span class="keywordflow">return</span> <a class="code" href="namespacestx.html#a9ba8a760ec020ea9b105ae6060494203">None</a>;</div><div class="line"> <span class="keywordflow">return</span> Some(num / denom);</div><div class="line">};</div><div class="line"></div><div class="line">EXPECT_DEATH(divide(0.0, 1.0).<a class="code" href="classstx_1_1Option.html#a44e064a8f29d3491ec611ea8cb035a43">unwrap_none</a>());</div><div class="line">EXPECT_NO_THROW(divide(1.0, 0.0).<a class="code" href="classstx_1_1Option.html#a44e064a8f29d3491ec611ea8cb035a43">unwrap_none</a>());</div></div><!-- fragment --> 
</div>
</div>
<a id="a89ec66ce64c657369fb79f39beed1d8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89ec66ce64c657369fb79f39beed1d8e">&#9670;&nbsp;</a></span>filter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T&gt; </div>
<div class="memtemplate">
template&lt;typename UnaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">requires <a class="el" href="namespacestx.html#aa8f14c3c14e6dcdecfdf0710ee2ed774">invocable</a>&lt;UnaryPredicate&amp;&amp;, T const&amp;&gt;&amp;&amp; <a class="el" href="namespacestx.html#aa0bd2b8f4938c62598f62d340bd74008">convertible_to</a>&lt;<a class="el" href="namespacestx.html#ac43d924d52c43f451ac8f9a9ae00934b">invoke_result</a>&lt;UnaryPredicate&amp;&amp;, T const&amp;&gt;, bool&gt; [[nodiscard]] constexpr auto <a class="el" href="classstx_1_1Option.html">stx::Option</a>&lt; T &gt;::filter </td>
          <td>(</td>
          <td class="paramtype">UnaryPredicate &amp;&amp;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td> &amp;&amp; -&gt; <a class="el" href="classstx_1_1Option.html">Option</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <code>None</code> if the option is <code>None</code>, otherwise calls <code>predicate</code> with the wrapped value and returns:</p>
<ul>
<li><code><a class="el" href="structstx_1_1Some.html">Some</a>&lt;T&gt;</code> if <code>predicate</code> returns <code>true</code> on invocation on the value.</li>
<li><code>None</code> if <code>predicate</code> returns <code>false</code> on invocation on the value.</li>
</ul>
<p><code><a class="el" href="classstx_1_1Option.html#a89ec66ce64c657369fb79f39beed1d8e">filter()</a></code> lets you decide which elements to keep.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> is_even = [](<span class="keywordtype">int</span> n) -&gt; <span class="keywordtype">bool</span> { <span class="keywordflow">return</span> n % 2 == 0; };</div><div class="line"></div><div class="line">ASSERT_EQ(make_none&lt;int&gt;().<a class="code" href="classstx_1_1Option.html#a89ec66ce64c657369fb79f39beed1d8e">filter</a>(is_even), <a class="code" href="namespacestx.html#a9ba8a760ec020ea9b105ae6060494203">None</a>);</div><div class="line">ASSERT_EQ(<a class="code" href="namespacestx.html#af3dd9531b7d03154feb5ab0b5230cd84">make_some</a>(3).<a class="code" href="classstx_1_1Option.html#a89ec66ce64c657369fb79f39beed1d8e">filter</a>(is_even), <a class="code" href="namespacestx.html#a9ba8a760ec020ea9b105ae6060494203">None</a>);</div><div class="line">ASSERT_EQ(<a class="code" href="namespacestx.html#af3dd9531b7d03154feb5ab0b5230cd84">make_some</a>(4).<a class="code" href="classstx_1_1Option.html#a89ec66ce64c657369fb79f39beed1d8e">filter</a>(is_even), Some(4));</div></div><!-- fragment --> 
</div>
</div>
<a id="ac014cc8bf8f92c1414bbd714c3b339b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac014cc8bf8f92c1414bbd714c3b339b3">&#9670;&nbsp;</a></span>filter_not()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T&gt; </div>
<div class="memtemplate">
template&lt;typename UnaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">requires <a class="el" href="namespacestx.html#aa8f14c3c14e6dcdecfdf0710ee2ed774">invocable</a>&lt;UnaryPredicate&amp;&amp;, T const&amp;&gt;&amp;&amp; <a class="el" href="namespacestx.html#aa0bd2b8f4938c62598f62d340bd74008">convertible_to</a>&lt;<a class="el" href="namespacestx.html#ac43d924d52c43f451ac8f9a9ae00934b">invoke_result</a>&lt;UnaryPredicate&amp;&amp;, T const&amp;&gt;, bool&gt; [[nodiscard]] constexpr auto <a class="el" href="classstx_1_1Option.html">stx::Option</a>&lt; T &gt;::filter_not </td>
          <td>(</td>
          <td class="paramtype">UnaryPredicate &amp;&amp;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td> &amp;&amp; -&gt; <a class="el" href="classstx_1_1Option.html">Option</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <code>None</code> if the option is <code>None</code>, otherwise calls <code>predicate</code> with the wrapped value and returns:</p>
<ul>
<li><code><a class="el" href="structstx_1_1Some.html">Some</a>&lt;T&gt;</code> if <code>predicate</code> returns <code>false</code> on invocation on the value.</li>
<li><code>None</code> if <code>predicate</code> returns <code>true</code> on invocation on the value.</li>
</ul>
<p><code><a class="el" href="classstx_1_1Option.html#ac014cc8bf8f92c1414bbd714c3b339b3">filter_not()</a></code> lets you decide which elements to keep.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> is_even = [](<span class="keywordtype">int</span> n) -&gt; <span class="keywordtype">bool</span> { <span class="keywordflow">return</span> n % 2 == 0; };</div><div class="line"></div><div class="line">ASSERT_EQ(make_none&lt;int&gt;().<a class="code" href="classstx_1_1Option.html#ac014cc8bf8f92c1414bbd714c3b339b3">filter_not</a>(is_even), <a class="code" href="namespacestx.html#a9ba8a760ec020ea9b105ae6060494203">None</a>);</div><div class="line">ASSERT_EQ(<a class="code" href="namespacestx.html#af3dd9531b7d03154feb5ab0b5230cd84">make_some</a>(3).<a class="code" href="classstx_1_1Option.html#ac014cc8bf8f92c1414bbd714c3b339b3">filter_not</a>(is_even), Some(3));</div><div class="line">ASSERT_EQ(<a class="code" href="namespacestx.html#af3dd9531b7d03154feb5ab0b5230cd84">make_some</a>(4).<a class="code" href="classstx_1_1Option.html#ac014cc8bf8f92c1414bbd714c3b339b3">filter_not</a>(is_even), <a class="code" href="namespacestx.html#a9ba8a760ec020ea9b105ae6060494203">None</a>);</div></div><!-- fragment --> 
</div>
</div>
<a id="a128eea3f6f6fc53507d53997f6c7b2f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a128eea3f6f6fc53507d53997f6c7b2f5">&#9670;&nbsp;</a></span>is_none()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classstx_1_1Option.html">stx::Option</a>&lt; T &gt;::is_none </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <code>true</code> if the option is a <code>None</code> value.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><a class="code" href="classstx_1_1Option.html#a9393450b154680722566eef0236a7765">Option</a> x = Some(2);</div><div class="line">ASSERT_FALSE(x.is_none());</div><div class="line"></div><div class="line">Option&lt;int&gt; y = <a class="code" href="namespacestx.html#a9ba8a760ec020ea9b105ae6060494203">None</a>;</div><div class="line">ASSERT_TRUE(y.is_none());</div></div><!-- fragment --> 
</div>
</div>
<a id="ac3b86d7f557309e46e6daa0a9dc0f0e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3b86d7f557309e46e6daa0a9dc0f0e5">&#9670;&nbsp;</a></span>is_some()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classstx_1_1Option.html">stx::Option</a>&lt; T &gt;::is_some </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <code>true</code> if this <a class="el" href="classstx_1_1Option.html">Option</a> is a <code><a class="el" href="structstx_1_1Some.html">Some</a></code> value.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><a class="code" href="classstx_1_1Option.html#a9393450b154680722566eef0236a7765">Option</a> x = Some(2);</div><div class="line">ASSERT_TRUE(x.is_some());</div><div class="line"></div><div class="line">Option&lt;int&gt; y = <a class="code" href="namespacestx.html#a9ba8a760ec020ea9b105ae6060494203">None</a>;</div><div class="line">ASSERT_FALSE(y.is_some());</div></div><!-- fragment --> 
</div>
</div>
<a id="af2801640e880c57771b4d86892fcdd97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2801640e880c57771b4d86892fcdd97">&#9670;&nbsp;</a></span>map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T&gt; </div>
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">requires <a class="el" href="namespacestx.html#aa8f14c3c14e6dcdecfdf0710ee2ed774">invocable</a>&lt;Fn&amp;&amp;, T&amp;&amp;&gt; [[nodiscard]] constexpr auto <a class="el" href="classstx_1_1Option.html">stx::Option</a>&lt; T &gt;::map </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> &amp;&amp; -&gt; <a class="el" href="classstx_1_1Option.html">Option</a>&lt;<a class="el" href="namespacestx.html#ac43d924d52c43f451ac8f9a9ae00934b">invoke_result</a>&lt;Fn&amp;&amp;, T&amp;&amp;&gt;&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Maps an <code><a class="el" href="classstx_1_1Option.html">Option</a>&lt;T&gt;</code> to <code><a class="el" href="classstx_1_1Option.html">Option</a>&lt;U&gt;</code> by applying a function to a contained value and therefore, consuming/moving the contained value.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<p>Converts an <code><a class="el" href="classstx_1_1Option.html">Option</a>&lt;string&gt;</code> into an <code><a class="el" href="classstx_1_1Option.html">Option</a>&lt;size_t&gt;</code>, consuming the original:</p>
<div class="fragment"><div class="line"><a class="code" href="classstx_1_1Option.html#a9393450b154680722566eef0236a7765">Option</a> maybe_string = Some(<span class="stringliteral">&quot;Hello, World!&quot;</span>s);</div><div class="line"><span class="comment">// `Option::map` will only work on Option as an r-value and assumes the</span></div><div class="line"><span class="comment">//  object in it is about to be moved</span></div><div class="line"><span class="keyword">auto</span> maybe_len = move(maybe_string).map([](<span class="keyword">auto</span> s){ <span class="keywordflow">return</span> s.size();</div><div class="line">});</div><div class="line"><span class="comment">// maybe_string is invalid and should not be used from here since we</span></div><div class="line"><span class="comment">// `std::move`-d from it</span></div><div class="line"></div><div class="line">ASSERT_EQ(maybe_len, Some&lt;size_t&gt;(13));</div></div><!-- fragment --> 
</div>
</div>
<a id="a47a5b2655a96e487de55fcd8565558f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47a5b2655a96e487de55fcd8565558f8">&#9670;&nbsp;</a></span>map_or()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T&gt; </div>
<div class="memtemplate">
template&lt;typename Fn , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">requires <a class="el" href="namespacestx.html#aa8f14c3c14e6dcdecfdf0710ee2ed774">invocable</a>&lt;Fn&amp;&amp;, T&amp;&amp;&gt; [[nodiscard]] constexpr auto <a class="el" href="classstx_1_1Option.html">stx::Option</a>&lt; T &gt;::map_or </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>alt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> &amp;&amp; -&gt; <a class="el" href="namespacestx.html#ac43d924d52c43f451ac8f9a9ae00934b">invoke_result</a>&lt;Fn&amp;&amp;, T&amp;&amp;&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies a function to the contained value (if any), or returns the provided alternative (if not).</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><a class="code" href="classstx_1_1Option.html#a9393450b154680722566eef0236a7765">Option</a> x = Some(<span class="stringliteral">&quot;foo&quot;</span>s);</div><div class="line"><span class="keyword">auto</span> alt_fn = [](<span class="keyword">auto</span> s) { <span class="keywordflow">return</span> s.size(); };</div><div class="line">ASSERT_EQ(move(x).<a class="code" href="classstx_1_1Option.html#a47a5b2655a96e487de55fcd8565558f8">map_or</a>(alt_fn, 42UL), 3UL);</div><div class="line"></div><div class="line">Option&lt;string&gt; y = <a class="code" href="namespacestx.html#a9ba8a760ec020ea9b105ae6060494203">None</a>;</div><div class="line">ASSERT_EQ(move(y).<a class="code" href="classstx_1_1Option.html#a47a5b2655a96e487de55fcd8565558f8">map_or</a>(alt_fn, 42UL), 42UL);</div></div><!-- fragment --> 
</div>
</div>
<a id="af7aa238131dafab4fda1508d310e1d95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7aa238131dafab4fda1508d310e1d95">&#9670;&nbsp;</a></span>map_or_else()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T&gt; </div>
<div class="memtemplate">
template&lt;typename Fn , typename AltFn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">requires <a class="el" href="namespacestx.html#aa8f14c3c14e6dcdecfdf0710ee2ed774">invocable</a>&lt;Fn&amp;&amp;, T&amp;&amp;&gt;&amp;&amp; <a class="el" href="namespacestx.html#aa8f14c3c14e6dcdecfdf0710ee2ed774">invocable</a>&lt;AltFn&amp;&amp;&gt; [[nodiscard]] constexpr auto <a class="el" href="classstx_1_1Option.html">stx::Option</a>&lt; T &gt;::map_or_else </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AltFn &amp;&amp;&#160;</td>
          <td class="paramname"><em>alt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> &amp;&amp; -&gt; <a class="el" href="namespacestx.html#ac43d924d52c43f451ac8f9a9ae00934b">invoke_result</a>&lt;Fn&amp;&amp;, T&amp;&amp;&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies a function to the contained value (if any), or computes a default (if not).</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><span class="keywordtype">size_t</span> k = 21;</div><div class="line"><span class="keyword">auto</span> map_fn = [] (<span class="keyword">auto</span> s) { <span class="keywordflow">return</span> s.size(); };</div><div class="line"><span class="keyword">auto</span> alt_fn = [&amp;k] () { <span class="keywordflow">return</span> 2UL * k; };</div><div class="line"></div><div class="line"><a class="code" href="classstx_1_1Option.html#a9393450b154680722566eef0236a7765">Option</a> x = Some(<span class="stringliteral">&quot;foo&quot;</span>s);</div><div class="line">ASSERT_EQ(move(x).<a class="code" href="classstx_1_1Option.html#af7aa238131dafab4fda1508d310e1d95">map_or_else</a>(map_fn, alt_fn), 3);</div><div class="line"></div><div class="line">Option&lt;string&gt; y = <a class="code" href="namespacestx.html#a9ba8a760ec020ea9b105ae6060494203">None</a>;</div><div class="line">ASSERT_EQ(move(y).<a class="code" href="classstx_1_1Option.html#af7aa238131dafab4fda1508d310e1d95">map_or_else</a>(map_fn, alt_fn), 42);</div></div><!-- fragment --> 
</div>
</div>
<a id="ac25e56a879bbb3de1f5db166f7ca8169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac25e56a879bbb3de1f5db166f7ca8169">&#9670;&nbsp;</a></span>match()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T&gt; </div>
<div class="memtemplate">
template&lt;typename SomeFn , typename NoneFn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">requires <a class="el" href="namespacestx.html#aa8f14c3c14e6dcdecfdf0710ee2ed774">invocable</a>&lt;SomeFn&amp;&amp;, T&amp;&amp;&gt;&amp;&amp; <a class="el" href="namespacestx.html#aa8f14c3c14e6dcdecfdf0710ee2ed774">invocable</a>&lt;NoneFn&amp;&amp;&gt; [[nodiscard]] constexpr auto <a class="el" href="classstx_1_1Option.html">stx::Option</a>&lt; T &gt;::match </td>
          <td>(</td>
          <td class="paramtype">SomeFn &amp;&amp;&#160;</td>
          <td class="paramname"><em>some_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NoneFn &amp;&amp;&#160;</td>
          <td class="paramname"><em>none_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> &amp;&amp; -&gt; <a class="el" href="namespacestx.html#ac43d924d52c43f451ac8f9a9ae00934b">invoke_result</a>&lt;SomeFn&amp;&amp;, T&amp;&amp;&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calls the parameter <code>some_fn</code> with the value if this <code><a class="el" href="classstx_1_1Option.html">Option</a></code> is a <code><a class="el" href="structstx_1_1Some.html">Some</a>&lt;T&gt;</code> variant, else calls <code>none_fn</code>. This <code><a class="el" href="classstx_1_1Option.html">Option</a></code> is consumed afterward.</p>
<p>The return type of both parameters must be same (without expecting implicit conversions). They can also both return nothing <code>void</code>.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> j = <a class="code" href="namespacestx.html#af3dd9531b7d03154feb5ab0b5230cd84">make_some</a>(<span class="stringliteral">&quot;James&quot;</span>s).match([](<span class="keywordtype">string</span> name) { <span class="keywordflow">return</span> name; },</div><div class="line">                                   []() { <span class="keywordflow">return</span> <span class="stringliteral">&quot;&lt;unidentified&gt;&quot;</span>s; });</div><div class="line">ASSERT_EQ(j, <span class="stringliteral">&quot;James&quot;</span>s);</div><div class="line"></div><div class="line"><span class="keyword">auto</span> k = make_none&lt;string&gt;().<a class="code" href="classstx_1_1Option.html#ac25e56a879bbb3de1f5db166f7ca8169">match</a>([](<span class="keywordtype">string</span> name) { <span class="keywordflow">return</span> name; },</div><div class="line">                                   []() { <span class="keywordflow">return</span> <span class="stringliteral">&quot;&lt;unidentified&gt;&quot;</span>s; });</div><div class="line">ASSERT_EQ(k, <span class="stringliteral">&quot;&lt;unidentified&gt;&quot;</span>s);</div></div><!-- fragment --> 
</div>
</div>
<a id="a8ab0da7b2c4f6396f6467cdf0ba59676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ab0da7b2c4f6396f6467cdf0ba59676">&#9670;&nbsp;</a></span>ok_or()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T&gt; </div>
<div class="memtemplate">
template&lt;typename E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classstx_1_1Option.html">stx::Option</a>&lt; T &gt;::ok_or </td>
          <td>(</td>
          <td class="paramtype">E&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td> &amp;&amp; -&gt; <a class="el" href="classstx_1_1Result.html">Result</a>&lt;T, E&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Transforms the <code><a class="el" href="classstx_1_1Option.html">Option</a>&lt;T&gt;</code> into a <code><a class="el" href="classstx_1_1Result.html">Result</a>&lt;T, E&gt;</code>, mapping <code><a class="el" href="structstx_1_1Some.html">Some</a>&lt;T&gt;</code> to <code><a class="el" href="structstx_1_1Ok.html">Ok</a>&lt;T&gt;</code> and <code>None</code> to <code><a class="el" href="structstx_1_1Err.html" title="error-value variant for Result&lt;T, E&gt; wrapping the contained error ">Err</a>&lt;E&gt;</code>.</p>
<p>Arguments passed to <code>ok_or</code> are eagerly evaluated; if you are passing the result of a function call, it is recommended to use <code>ok_or_else</code>, which is lazily evaluated.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><a class="code" href="classstx_1_1Option.html#a9393450b154680722566eef0236a7765">Option</a> x = Some(<span class="stringliteral">&quot;foo&quot;</span>s);</div><div class="line">ASSERT_EQ(move(x).<a class="code" href="classstx_1_1Option.html#a8ab0da7b2c4f6396f6467cdf0ba59676">ok_or</a>(0), Ok(<span class="stringliteral">&quot;foo&quot;</span>s));</div><div class="line"></div><div class="line">Option&lt;string&gt; y = <a class="code" href="namespacestx.html#a9ba8a760ec020ea9b105ae6060494203">None</a>;</div><div class="line">ASSERT_EQ(move(y).<a class="code" href="classstx_1_1Option.html#a8ab0da7b2c4f6396f6467cdf0ba59676">ok_or</a>(0), Err(0));</div></div><!-- fragment --> 
</div>
</div>
<a id="a22db8455dda38c384e9dcd423a4cb4cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22db8455dda38c384e9dcd423a4cb4cd">&#9670;&nbsp;</a></span>ok_or_else()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T&gt; </div>
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">requires <a class="el" href="namespacestx.html#aa8f14c3c14e6dcdecfdf0710ee2ed774">invocable</a>&lt;Fn&amp;&amp;&gt; [[nodiscard]] constexpr auto <a class="el" href="classstx_1_1Option.html">stx::Option</a>&lt; T &gt;::ok_or_else </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> &amp;&amp; -&gt; <a class="el" href="classstx_1_1Result.html">Result</a>&lt;T, <a class="el" href="namespacestx.html#ac43d924d52c43f451ac8f9a9ae00934b">invoke_result</a>&lt;Fn&amp;&amp;&gt;&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Transforms the <code><a class="el" href="classstx_1_1Option.html">Option</a>&lt;T&gt;</code> into a <code><a class="el" href="classstx_1_1Result.html">Result</a>&lt;T, E&gt;</code>, mapping <code><a class="el" href="structstx_1_1Some.html">Some</a>&lt;T&gt;</code> to <code><a class="el" href="structstx_1_1Ok.html">Ok</a>&lt;T&gt;</code> and <code>None</code> to <code>Err(op())</code>.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> else_fn = [] () { <span class="keywordflow">return</span> 0; };</div><div class="line"></div><div class="line"><a class="code" href="classstx_1_1Option.html#a9393450b154680722566eef0236a7765">Option</a> x = Some(<span class="stringliteral">&quot;foo&quot;</span>s);</div><div class="line">ASSERT_EQ(move(x).<a class="code" href="classstx_1_1Option.html#a22db8455dda38c384e9dcd423a4cb4cd">ok_or_else</a>(else_fn), Ok(<span class="stringliteral">&quot;foo&quot;</span>s));</div><div class="line"></div><div class="line">Option&lt;string&gt; y = <a class="code" href="namespacestx.html#a9ba8a760ec020ea9b105ae6060494203">None</a>;</div><div class="line">ASSERT_EQ(move(y).<a class="code" href="classstx_1_1Option.html#a22db8455dda38c384e9dcd423a4cb4cd">ok_or_else</a>(else_fn), Err(0));</div></div><!-- fragment --> 
</div>
</div>
<a id="a3bb91a7c281b9697dea63c4f1adeb75e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bb91a7c281b9697dea63c4f1adeb75e">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstx_1_1Option.html">Option</a>&amp; <a class="el" href="classstx_1_1Option.html">stx::Option</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstx_1_1Option.html">Option</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2cf6e3dd7a810f2562b7a4172376e27b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cf6e3dd7a810f2562b7a4172376e27b">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classstx_1_1Option.html">Option</a>&amp; <a class="el" href="classstx_1_1Option.html">stx::Option</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstx_1_1Option.html">Option</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5870b47d3d5e11e9f05cf824f35706cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5870b47d3d5e11e9f05cf824f35706cc">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classstx_1_1Option.html">stx::Option</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstx_1_1Option.html">Option</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>cmp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abd19bcd9e6781ed5f307ae7325d8b530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd19bcd9e6781ed5f307ae7325d8b530">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classstx_1_1Option.html">stx::Option</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1Some.html">Some</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>cmp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad625f94aa00e46c7f96007dd06b0001a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad625f94aa00e46c7f96007dd06b0001a">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classstx_1_1Option.html">stx::Option</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1Some.html">Some</a>&lt; <a class="el" href="namespacestx.html#a910046924ff264eb1eec0707011908ee">ConstRef</a>&lt; T &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>cmp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a037940002bbb957fc1c8700fca9ab183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a037940002bbb957fc1c8700fca9ab183">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classstx_1_1Option.html">stx::Option</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1Some.html">Some</a>&lt; <a class="el" href="namespacestx.html#a1b55420e0cd6b42317f23d32831d1637">MutRef</a>&lt; T &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>cmp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a90e57f7ca55330e0b484cad81af9d1ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90e57f7ca55330e0b484cad81af9d1ea">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classstx_1_1Option.html">stx::Option</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1Some.html">Some</a>&lt; const T *&gt; const &amp;&#160;</td>
          <td class="paramname"><em>cmp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a39e0a8f049984b4d891a430afce45476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39e0a8f049984b4d891a430afce45476">&#9670;&nbsp;</a></span>operator==() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classstx_1_1Option.html">stx::Option</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1Some.html">Some</a>&lt; T *&gt; const &amp;&#160;</td>
          <td class="paramname"><em>cmp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a606004ec5662ae1db49f54fed2cd58bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a606004ec5662ae1db49f54fed2cd58bd">&#9670;&nbsp;</a></span>operator==() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classstx_1_1Option.html">stx::Option</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstx_1_1NoneType.html">NoneType</a> const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7845c47770ef65233727d1fb0eb2e876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7845c47770ef65233727d1fb0eb2e876">&#9670;&nbsp;</a></span>OR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classstx_1_1Option.html">stx::Option</a>&lt; T &gt;::OR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstx_1_1Option.html">Option</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>alt</em></td><td>)</td>
          <td> &amp;&amp; -&gt; <a class="el" href="classstx_1_1Option.html">Option</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the option if it contains a value, otherwise returns <code>alt</code>.</p>
<p>Arguments passed to <code>OR</code> are eagerly evaluated; if you are passing the result of a function call, it is recommended to use <code>or_else</code>, which is lazily evaluated.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><a class="code" href="classstx_1_1Option.html#a9393450b154680722566eef0236a7765">Option</a> a = Some(2);</div><div class="line">Option&lt;int&gt; b = <a class="code" href="namespacestx.html#a9ba8a760ec020ea9b105ae6060494203">None</a>;</div><div class="line">ASSERT_EQ(move(a).<a class="code" href="classstx_1_1Option.html#a7845c47770ef65233727d1fb0eb2e876">OR</a>(move(b)), Some(2));</div><div class="line"></div><div class="line">Option&lt;int&gt; c = <a class="code" href="namespacestx.html#a9ba8a760ec020ea9b105ae6060494203">None</a>;</div><div class="line"><a class="code" href="classstx_1_1Option.html#a9393450b154680722566eef0236a7765">Option</a> d = Some(100);</div><div class="line">ASSERT_EQ(move(c).<a class="code" href="classstx_1_1Option.html#a7845c47770ef65233727d1fb0eb2e876">OR</a>(move(d)), Some(100));</div><div class="line"></div><div class="line"><a class="code" href="classstx_1_1Option.html#a9393450b154680722566eef0236a7765">Option</a> e = Some(2);</div><div class="line"><a class="code" href="classstx_1_1Option.html#a9393450b154680722566eef0236a7765">Option</a> f = Some(100);</div><div class="line">ASSERT_EQ(move(e).<a class="code" href="classstx_1_1Option.html#a7845c47770ef65233727d1fb0eb2e876">OR</a>(move(f)), Some(2));</div><div class="line"></div><div class="line">Option&lt;int&gt; g = <a class="code" href="namespacestx.html#a9ba8a760ec020ea9b105ae6060494203">None</a>;</div><div class="line">Option&lt;int&gt; h = <a class="code" href="namespacestx.html#a9ba8a760ec020ea9b105ae6060494203">None</a>;</div><div class="line">ASSERT_EQ(move(g).<a class="code" href="classstx_1_1Option.html#a7845c47770ef65233727d1fb0eb2e876">OR</a>(move(h)), <a class="code" href="namespacestx.html#a9ba8a760ec020ea9b105ae6060494203">None</a>);</div></div><!-- fragment --> 
</div>
</div>
<a id="a65cffaea7874d4985324807e87766735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65cffaea7874d4985324807e87766735">&#9670;&nbsp;</a></span>or_else()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T&gt; </div>
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">requires <a class="el" href="namespacestx.html#aa8f14c3c14e6dcdecfdf0710ee2ed774">invocable</a>&lt;Fn&amp;&amp;&gt; [[nodiscard]] constexpr auto <a class="el" href="classstx_1_1Option.html">stx::Option</a>&lt; T &gt;::or_else </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> &amp;&amp; -&gt; <a class="el" href="classstx_1_1Option.html">Option</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the option if it contains a value, otherwise calls <code>f</code> and returns the result.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> nobody = []() -&gt; Option&lt;string&gt; { <span class="keywordflow">return</span> <a class="code" href="namespacestx.html#a9ba8a760ec020ea9b105ae6060494203">None</a>; };</div><div class="line"><span class="keyword">auto</span> vikings = []() -&gt; Option&lt;string&gt; { <span class="keywordflow">return</span> Some(<span class="stringliteral">&quot;vikings&quot;</span>s); };</div><div class="line"></div><div class="line">ASSERT_EQ(<a class="code" href="classstx_1_1Option.html#a9393450b154680722566eef0236a7765">Option</a>(Some(<span class="stringliteral">&quot;barbarians&quot;</span>s)).<a class="code" href="classstx_1_1Option.html#a65cffaea7874d4985324807e87766735">or_else</a>(vikings),</div><div class="line">Some(<span class="stringliteral">&quot;barbarians&quot;</span>s));</div><div class="line">ASSERT_EQ(make_none&lt;string&gt;().<a class="code" href="classstx_1_1Option.html#a65cffaea7874d4985324807e87766735">or_else</a>(vikings), Some(<span class="stringliteral">&quot;vikings&quot;</span>s));</div><div class="line">ASSERT_EQ(make_none&lt;string&gt;().<a class="code" href="classstx_1_1Option.html#a65cffaea7874d4985324807e87766735">or_else</a>(nobody), <a class="code" href="namespacestx.html#a9ba8a760ec020ea9b105ae6060494203">None</a>);</div></div><!-- fragment --> 
</div>
</div>
<a id="acd2fe0fddbd977bbb36f795d86357fb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd2fe0fddbd977bbb36f795d86357fb2">&#9670;&nbsp;</a></span>replace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classstx_1_1Option.html">stx::Option</a>&lt; T &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>replacement</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classstx_1_1Option.html">Option</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Replaces the actual value in the option by the value given in parameter, returning the old value if present, leaving a <code><a class="el" href="structstx_1_1Some.html">Some</a></code> in its place without deinitializing either one.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><a class="code" href="classstx_1_1Option.html#a9393450b154680722566eef0236a7765">Option</a> x = Some(2);</div><div class="line"><span class="keyword">auto</span> old_x = x.replace(5);</div><div class="line">ASSERT_EQ(x, Some(5));</div><div class="line">ASSERT_EQ(old_x, Some(2));</div><div class="line"></div><div class="line">Option&lt;int&gt; y = <a class="code" href="namespacestx.html#a9ba8a760ec020ea9b105ae6060494203">None</a>;</div><div class="line"><span class="keyword">auto</span> old_y = y.replace(3);</div><div class="line">ASSERT_EQ(y, Some(3));</div><div class="line">ASSERT_EQ(old_y, <a class="code" href="namespacestx.html#a9ba8a760ec020ea9b105ae6060494203">None</a>);</div></div><!-- fragment --> 
</div>
</div>
<a id="a8cefdccb8d729acf6f1c398f5a72bc65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cefdccb8d729acf6f1c398f5a72bc65">&#9670;&nbsp;</a></span>replace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classstx_1_1Option.html">stx::Option</a>&lt; T &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>replacement</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classstx_1_1Option.html">Option</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Replaces the actual value in the option by the value given in parameter, returning the old value if present, leaving a <code><a class="el" href="structstx_1_1Some.html">Some</a></code> in its place without deinitializing either one.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><a class="code" href="classstx_1_1Option.html#a9393450b154680722566eef0236a7765">Option</a> x = Some(2);</div><div class="line"><span class="keyword">auto</span> old_x = x.replace(5);</div><div class="line">ASSERT_EQ(x, Some(5));</div><div class="line">ASSERT_EQ(old_x, Some(2));</div><div class="line"></div><div class="line">Option&lt;int&gt; y = <a class="code" href="namespacestx.html#a9ba8a760ec020ea9b105ae6060494203">None</a>;</div><div class="line"><span class="keyword">auto</span> old_y = y.replace(3);</div><div class="line">ASSERT_EQ(y, Some(3));</div><div class="line">ASSERT_EQ(old_y, <a class="code" href="namespacestx.html#a9ba8a760ec020ea9b105ae6060494203">None</a>);</div></div><!-- fragment --> 
</div>
</div>
<a id="aa4df8a6637e0bfe0dd18bbbeb7caa0c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4df8a6637e0bfe0dd18bbbeb7caa0c0">&#9670;&nbsp;</a></span>take()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classstx_1_1Option.html">stx::Option</a>&lt; T &gt;::take </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="classstx_1_1Option.html">Option</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Takes the value out of the option, leaving a <code>None</code> in its place.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><a class="code" href="classstx_1_1Option.html#a9393450b154680722566eef0236a7765">Option</a> a = Some(2);</div><div class="line"><span class="keyword">auto</span> b = a.take();</div><div class="line">ASSERT_EQ(a, <a class="code" href="namespacestx.html#a9ba8a760ec020ea9b105ae6060494203">None</a>);</div><div class="line">ASSERT_EQ(b, Some(2));</div><div class="line"></div><div class="line">Option&lt;int&gt; c  = <a class="code" href="namespacestx.html#a9ba8a760ec020ea9b105ae6060494203">None</a>;</div><div class="line"><span class="keyword">auto</span> d = c.take();</div><div class="line">ASSERT_EQ(c, <a class="code" href="namespacestx.html#a9ba8a760ec020ea9b105ae6060494203">None</a>);</div><div class="line">ASSERT_EQ(d, <a class="code" href="namespacestx.html#a9ba8a760ec020ea9b105ae6060494203">None</a>);</div></div><!-- fragment --> 
</div>
</div>
<a id="ab7d8354aa8d2ae9df4d35876a5a45a41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7d8354aa8d2ae9df4d35876a5a45a41">&#9670;&nbsp;</a></span>unwrap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classstx_1_1Option.html">stx::Option</a>&lt; T &gt;::unwrap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp; -&gt; T </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Moves the value out of the <code><a class="el" href="classstx_1_1Option.html">Option</a>&lt;T&gt;</code> if it is in the variant state of <code><a class="el" href="structstx_1_1Some.html">Some</a>&lt;T&gt;</code>.</p>
<p>In general, because this function may panic, its use is discouraged. Instead, prefer to use pattern matching and handle the <code>None</code> case explicitly.</p>
<h1>Panics</h1>
<p>Panics if its value equals <code>None</code>.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><a class="code" href="classstx_1_1Option.html#a9393450b154680722566eef0236a7765">Option</a> x = Some(<span class="stringliteral">&quot;air&quot;</span>s);</div><div class="line">ASSERT_EQ(move(x).<a class="code" href="classstx_1_1Option.html#ab7d8354aa8d2ae9df4d35876a5a45a41">unwrap</a>(), <span class="stringliteral">&quot;air&quot;</span>);</div><div class="line"></div><div class="line">Option&lt;string&gt; y = <a class="code" href="namespacestx.html#a9ba8a760ec020ea9b105ae6060494203">None</a>;</div><div class="line">ASSERT_ANY_THROW(move(y).<a class="code" href="classstx_1_1Option.html#ab7d8354aa8d2ae9df4d35876a5a45a41">unwrap</a>());</div></div><!-- fragment --> 
</div>
</div>
<a id="a44e064a8f29d3491ec611ea8cb035a43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44e064a8f29d3491ec611ea8cb035a43">&#9670;&nbsp;</a></span>unwrap_none()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstx_1_1Option.html">stx::Option</a>&lt; T &gt;::unwrap_none </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unwraps an option, expecting <code>None</code> and returning nothing.</p>
<h1>Panics</h1>
<p>Panics if the value is a <code><a class="el" href="structstx_1_1Some.html">Some</a></code>, with a panic message including the passed message, and the content of the <code><a class="el" href="structstx_1_1Some.html">Some</a></code>.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> divide = [](<span class="keywordtype">double</span> num, <span class="keywordtype">double</span> denom) -&gt; Option&lt;double&gt; {</div><div class="line"><span class="keywordflow">if</span> (denom == 0.0) <span class="keywordflow">return</span> <a class="code" href="namespacestx.html#a9ba8a760ec020ea9b105ae6060494203">None</a>;</div><div class="line"> <span class="keywordflow">return</span> Some(num / denom);</div><div class="line">};</div><div class="line"></div><div class="line">EXPECT_DEATH(divide(0.0, 1.0).<a class="code" href="classstx_1_1Option.html#aca4ecfffb340613fb8e00b0fb0189c72">expect_none</a>(<span class="stringliteral">&quot;zero dividend&quot;</span>));</div><div class="line">EXPECT_NO_THROW(divide(1.0, 0.0).<a class="code" href="classstx_1_1Option.html#aca4ecfffb340613fb8e00b0fb0189c72">expect_none</a>(<span class="stringliteral">&quot;zero dividend&quot;</span>));</div></div><!-- fragment --> 
</div>
</div>
<a id="ad699fe761b32bc9e64511a5619943155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad699fe761b32bc9e64511a5619943155">&#9670;&nbsp;</a></span>unwrap_or()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classstx_1_1Option.html">stx::Option</a>&lt; T &gt;::unwrap_or </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>alt</em></td><td>)</td>
          <td> &amp;&amp; -&gt; T </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the contained value or an alternative: <code>alt</code>.</p>
<p>Arguments passed to <code>unwrap_or</code> are eagerly evaluated; if you are passing the result of a function call, it is recommended to use <code>unwrap_or_else</code>, which is lazily evaluated.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line">ASSERT_EQ(<a class="code" href="classstx_1_1Option.html#a9393450b154680722566eef0236a7765">Option</a>(Some(<span class="stringliteral">&quot;car&quot;</span>s)).<a class="code" href="classstx_1_1Option.html#ad699fe761b32bc9e64511a5619943155">unwrap_or</a>(<span class="stringliteral">&quot;bike&quot;</span>), <span class="stringliteral">&quot;car&quot;</span>);</div><div class="line">ASSERT_EQ(make_none&lt;string&gt;().<a class="code" href="classstx_1_1Option.html#ad699fe761b32bc9e64511a5619943155">unwrap_or</a>(<span class="stringliteral">&quot;bike&quot;</span>), <span class="stringliteral">&quot;bike&quot;</span>);</div></div><!-- fragment --> 
</div>
</div>
<a id="a7cba1e1ee68ea9b84817707017ab5421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cba1e1ee68ea9b84817707017ab5421">&#9670;&nbsp;</a></span>unwrap_or_default()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classstx_1_1Option.html">stx::Option</a>&lt; T &gt;::unwrap_or_default </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp; -&gt; T
      requires <a class="el" href="namespacestx.html#a33c4edb845e3f658de071107790b37bc">default_constructible</a>&lt;T&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the contained value or a default of T</p>
<p>Consumes this object and returns its <code><a class="el" href="structstx_1_1Some.html">Some</a>&lt;T&gt;</code> value if it is a <code><a class="el" href="structstx_1_1Some.html">Some</a>&lt;T&gt;</code> variant, else if this object is a <code>None</code> variant, returns the default of the value type <code>T</code>.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><a class="code" href="classstx_1_1Option.html#a9393450b154680722566eef0236a7765">Option</a> x = Some(<span class="stringliteral">&quot;Ten&quot;</span>s);</div><div class="line">Option&lt;string&gt; y = <a class="code" href="namespacestx.html#a9ba8a760ec020ea9b105ae6060494203">None</a>;</div><div class="line"></div><div class="line">ASSERT_EQ(move(x).<a class="code" href="classstx_1_1Option.html#a7cba1e1ee68ea9b84817707017ab5421">unwrap_or_default</a>(), <span class="stringliteral">&quot;Ten&quot;</span>s);</div><div class="line">ASSERT_EQ(move(y).<a class="code" href="classstx_1_1Option.html#a7cba1e1ee68ea9b84817707017ab5421">unwrap_or_default</a>(), <span class="stringliteral">&quot;&quot;</span>s);</div></div><!-- fragment --> 
</div>
</div>
<a id="adc871a59892bc4111dad2e8c9fde48ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc871a59892bc4111dad2e8c9fde48ff">&#9670;&nbsp;</a></span>unwrap_or_else()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T&gt; </div>
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">requires <a class="el" href="namespacestx.html#aa8f14c3c14e6dcdecfdf0710ee2ed774">invocable</a>&lt;Fn&amp;&amp;&gt; [[nodiscard]] constexpr auto <a class="el" href="classstx_1_1Option.html">stx::Option</a>&lt; T &gt;::unwrap_or_else </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> &amp;&amp; -&gt; T </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the contained value or computes it from a closure.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> k = 10;</div><div class="line"><span class="keyword">auto</span> alt = [&amp;k]() { <span class="keywordflow">return</span> 2 * k; };</div><div class="line"></div><div class="line">ASSERT_EQ(<a class="code" href="namespacestx.html#af3dd9531b7d03154feb5ab0b5230cd84">make_some</a>(4).<a class="code" href="classstx_1_1Option.html#adc871a59892bc4111dad2e8c9fde48ff">unwrap_or_else</a>(alt), 4);</div><div class="line">ASSERT_EQ(make_none&lt;int&gt;().<a class="code" href="classstx_1_1Option.html#adc871a59892bc4111dad2e8c9fde48ff">unwrap_or_else</a>(alt), 20);</div></div><!-- fragment --> 
</div>
</div>
<a id="a1a4235a790f4a64af1877ec8fd85668d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a4235a790f4a64af1877ec8fd85668d">&#9670;&nbsp;</a></span>value() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classstx_1_1Option.html">stx::Option</a>&lt; T &gt;::value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an l-value reference to the contained value. Note that no copying occurs here.</p>
<h1>Panics</h1>
<p>Panics if the value is a <code>None</code></p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> x = <a class="code" href="namespacestx.html#af3dd9531b7d03154feb5ab0b5230cd84">make_some</a>(9);</div><div class="line"><span class="keywordtype">int</span>&amp; y = x.value();</div><div class="line">y = 2;</div><div class="line"></div><div class="line">ASSERT_EQ(x, Some(2));</div></div><!-- fragment --> 
</div>
</div>
<a id="ad34cb398d371752ccda7a7d1365c612a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad34cb398d371752ccda7a7d1365c612a">&#9670;&nbsp;</a></span>value() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T const&amp; <a class="el" href="classstx_1_1Option.html">stx::Option</a>&lt; T &gt;::value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a const l-value reference to the contained value. Note that no copying occurs here.</p>
<h1>Panics</h1>
<p>Panics if the value is a <code>None</code></p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> <span class="keyword">const</span> x = <a class="code" href="namespacestx.html#af3dd9531b7d03154feb5ab0b5230cd84">make_some</a>(9);</div><div class="line"><span class="keywordtype">int</span> <span class="keyword">const</span>&amp; y = x.value();</div><div class="line"></div><div class="line">ASSERT_EQ(y, 9);</div></div><!-- fragment --> 
</div>
</div>
<a id="a050734af1cb048d3ac2d590be377a273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a050734af1cb048d3ac2d590be377a273">&#9670;&nbsp;</a></span>value() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classstx_1_1Option.html">stx::Option</a>&lt; T &gt;::value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use <code><a class="el" href="classstx_1_1Option.html#ab7d8354aa8d2ae9df4d35876a5a45a41">unwrap()</a></code> instead. </p>

</div>
</div>
<a id="a12035d3b7bc6158c4bf4a291f866fb0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12035d3b7bc6158c4bf4a291f866fb0b">&#9670;&nbsp;</a></span>value() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T const <a class="el" href="classstx_1_1Option.html">stx::Option</a>&lt; T &gt;::value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use <code><a class="el" href="classstx_1_1Option.html#ab7d8354aa8d2ae9df4d35876a5a45a41">unwrap()</a></code> instead. </p>

</div>
</div>
<a id="a93ab884632f021c095f5a64ebc14b54d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93ab884632f021c095f5a64ebc14b54d">&#9670;&nbsp;</a></span>XOR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classstx_1_1Option.html">stx::Option</a>&lt; T &gt;::XOR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstx_1_1Option.html">Option</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>alt</em></td><td>)</td>
          <td> &amp;&amp; -&gt; <a class="el" href="classstx_1_1Option.html">Option</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whichever one of this object or <code>alt</code> is a <code><a class="el" href="structstx_1_1Some.html">Some</a>&lt;T&gt;</code> variant, otherwise returns <code>None</code> if neither or both are a <code><a class="el" href="structstx_1_1Some.html">Some</a>&lt;T&gt;</code> variant.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><a class="code" href="classstx_1_1Option.html#a9393450b154680722566eef0236a7765">Option</a> a = Some(2);</div><div class="line">Option&lt;int&gt; b = <a class="code" href="namespacestx.html#a9ba8a760ec020ea9b105ae6060494203">None</a>;</div><div class="line">ASSERT_EQ(move(a).<a class="code" href="classstx_1_1Option.html#a93ab884632f021c095f5a64ebc14b54d">XOR</a>(move(b)), Some(2));</div><div class="line"></div><div class="line">Option&lt;int&gt; c = <a class="code" href="namespacestx.html#a9ba8a760ec020ea9b105ae6060494203">None</a>;</div><div class="line"><a class="code" href="classstx_1_1Option.html#a9393450b154680722566eef0236a7765">Option</a> d = Some(2);</div><div class="line">ASSERT_EQ(move(c).<a class="code" href="classstx_1_1Option.html#a93ab884632f021c095f5a64ebc14b54d">XOR</a>(move(d)), Some(2));</div><div class="line"></div><div class="line"><a class="code" href="classstx_1_1Option.html#a9393450b154680722566eef0236a7765">Option</a> e = Some(2);</div><div class="line"><a class="code" href="classstx_1_1Option.html#a9393450b154680722566eef0236a7765">Option</a> f = Some(2);</div><div class="line">ASSERT_EQ(move(e).<a class="code" href="classstx_1_1Option.html#a93ab884632f021c095f5a64ebc14b54d">XOR</a>(move(f)), <a class="code" href="namespacestx.html#a9ba8a760ec020ea9b105ae6060494203">None</a>);</div><div class="line"></div><div class="line">Option&lt;int&gt; g = <a class="code" href="namespacestx.html#a9ba8a760ec020ea9b105ae6060494203">None</a>;</div><div class="line">Option&lt;int&gt; h = <a class="code" href="namespacestx.html#a9ba8a760ec020ea9b105ae6060494203">None</a>;</div><div class="line">ASSERT_EQ(move(g).<a class="code" href="classstx_1_1Option.html#a93ab884632f021c095f5a64ebc14b54d">XOR</a>(move(h)), <a class="code" href="namespacestx.html#a9ba8a760ec020ea9b105ae6060494203">None</a>);</div></div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ab1498e91710137969923d0f2931a2093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1498e91710137969923d0f2931a2093">&#9670;&nbsp;</a></span>storage_value_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classstx_1_1Option.html">stx::Option</a>&lt; T &gt;::storage_value_</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/stx/internal/<a class="el" href="option__result_8h_source.html">option_result.h</a></li>
</ul>
<div class="dynheader">
Inheritance diagram for stx::Option&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classstx_1_1Option__inherit__graph.png" border="0" usemap="#stx_1_1Option_3_01T_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="stx_1_1Option_3_01T_01_4_inherit__map" id="stx_1_1Option_3_01T_01_4_inherit__map">
<area shape="rect" id="node2" href="classstx_1_1Option.html" title="stx::Option\&lt; stx::backtrace\l::Symbol \&gt;" alt="" coords="5,95,244,136"/>
<area shape="rect" id="node3" href="classstx_1_1Option.html" title="stx::Option\&lt; uintptr_t \&gt;" alt="" coords="268,102,483,129"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer" />
<address class="footer"><small>
    Generated by &#160;<a href="http://www.doxygen.org/index.html"> Doxygen
    </a> 1.8.13
  </small></address>
<script type="text/javascript">
  (() => {
    document.body.onload = (() => {
      //
      //
      let clipboard_icon = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"\
      class="copy-icon dimming-wrap">\
      <path d="M0 0h24v24H0z"  fill="none"/>\
      <path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 \
      2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/>\
      </svg>';
      for (let x of document.querySelectorAll("div.fragment")) {
        if (x.querySelector(".lineno") == null)
          x.innerHTML = clipboard_icon + x.innerHTML;
      };
      for (let copy_icon of document.querySelectorAll(".copy-icon")) {
        copy_icon.onclick = () => {
          let code_content = "";
          for (let line of copy_icon.parentElement.querySelectorAll(".line")) {
            code_content = code_content.concat(line.textContent);
            code_content = code_content.concat("\n");
          }
          navigator.clipboard.writeText(code_content);
          alert("Copied to Clipboard");
        };
      };
    });
  })();
</script>
</body>
</html>