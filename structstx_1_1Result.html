<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=9" />
    <meta name="generator" content="Doxygen 1.8.13" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>STX: stx::Result&lt; T, E &gt; Struct Template Reference</title>
    <link href="tabs.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <link href="styles.css" rel="stylesheet" type="text/css" />
</head>
<body>
    <script>
        /*
                // light mode, dark mode
                color: ["#333", "#DDD"],
                backgroundColor: ["#FFFFFF", "#353535"],
                cardBackgroundColor: ["#F5F5F5", "#2A2A2A"],
                linkColor: ["#3D578C", "#D2991D"],
                headerBackgroundColor: ["#F1F1F1", "#505050"],
                headerHoverBackgroundColor: ["#F5F5F5", "#444"],
                // memtitle, memproto, memitemleft, memitemright 
                docprotoBackgroundColor: ["#FAFAFA", "2A2A2A"]
        */
        function switchTheme() {
            let theme = localStorage.getItem("theme");
            if (theme == "light" || theme == null) {
                document.body.className = "dark-theme";
                localStorage.setItem("theme", "dark");
            } else {
                document.body.className = "";
                localStorage.setItem("theme", "light");
            }
        }
        (function loadTheme() {
            let theme = localStorage.getItem("theme");
            console.log("theme:" + theme);
            if (theme == "light" || theme == null) {
                document.body.className = "";
            } else {
                document.body.className = "dark-theme";
            }
        })();
    </script>
    <div class="theme-switch dimming-wrap" onclick="switchTheme()">
        <div>
            <svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 48 48">
                <path
                    d="M42 6H6c-2.21 0-4 1.79-4 4v28c0 2.21 1.79 4 4 4h36c2.21 0 4-1.79 4-4V10c0-2.21-1.79-4-4-4zm0 32.03H6V9.97h36v28.06zM16 32h5l3 3 3-3h5v-5l3-3-3-3v-5h-5l-3-3-3 3h-5v5l-3 3 3 3v5zm8-14c3.31 0 6 2.69 6 6s-2.69 6-6 6V18z" />
            </svg></div>
    </div>
    <div id="top">
        <!-- do not remove this div, it is closed by doxygen! -->
        <div id="titlearea">
            <table cellspacing="0" cellpadding="0">
                <tbody>
                    <tr style="height: 56px;">
                        <td id="projectlogo"><img alt="Logo"
                                src="eagle.png" /></td>
                        <td id="projectalign" style="padding-left: 0.5em;">
                            <div id="projectname"> STX
                                &#160;<span id="projectnumber">1.0.0</span>
                            </div>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
        <!-- end header part --><!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacestx.html">stx</a></li><li class="navelem"><a class="el" href="structstx_1_1Result.html">Result</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="structstx_1_1Result-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">stx::Result&lt; T, E &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="option__result_8h_source.html">option_result.h</a>&gt;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename E&gt;<br />
struct stx::Result&lt; T, E &gt;</h3>

<h3>Error handling with the <code><a class="el" href="structstx_1_1Result.html">Result</a></code> type.</h3>
<p><code><a class="el" href="structstx_1_1Result.html">Result</a>&lt;T, E&gt;</code> is a type used for returning and propagating errors. It is a class with the variants: <code><a class="el" href="structstx_1_1Ok.html">Ok</a>&lt;T&gt;</code>, representing success and containing a value, and <code><a class="el" href="structstx_1_1Err.html">Err</a>&lt;E&gt;</code>, representing error and containing an error value.</p>
<p>Functions return <code><a class="el" href="structstx_1_1Result.html">Result</a></code> whenever errors are expected and recoverable.</p>
<p>A simple function returning <code><a class="el" href="structstx_1_1Result.html">Result</a></code> might be defined and used like so:</p>
<div class="fragment"><div class="line"><span class="keyword">enum class</span> Version { Version1 = 1, Version2 = 2 };</div><div class="line"></div><div class="line"><span class="keyword">auto</span> parse_version =</div><div class="line">     [](array&lt;uint8_t, 5&gt; <span class="keyword">const</span>&amp; header) -&gt; Result&lt;Version, string_view&gt; {</div><div class="line">   <span class="keywordflow">switch</span> (header.at(0)) {</div><div class="line">     <span class="keywordflow">case</span> 1:</div><div class="line">       <span class="keywordflow">return</span> Ok(Version::Version1);</div><div class="line">     <span class="keywordflow">case</span> 2:</div><div class="line">       <span class="keywordflow">return</span> Ok(Version::Version2);</div><div class="line">     <span class="keywordflow">default</span>:</div><div class="line">       <span class="keywordflow">return</span> Err(<span class="stringliteral">&quot;invalid version&quot;</span>sv);</div><div class="line">   }</div><div class="line"> };</div><div class="line"></div><div class="line">parse_version({1, 2, 3, 4, 5})</div><div class="line">     .<a class="code" href="structstx_1_1Result.html#aead72098ed0268c631b45aed236c4c67">match</a>(</div><div class="line">         [](<span class="keyword">auto</span> version) {</div><div class="line">           std::cout &lt;&lt; <span class="stringliteral">&quot;Working with version: &quot;</span></div><div class="line">                     &lt;&lt; <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(version) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">         },</div><div class="line">         [](<span class="keyword">auto</span> <a class="code" href="structstx_1_1Result.html#a4548a280df6c073e970fb7492e64b738">err</a>) {</div><div class="line">           std::cout &lt;&lt; <span class="stringliteral">&quot;Error parsing header: &quot;</span> &lt;&lt; <a class="code" href="structstx_1_1Result.html#a4548a280df6c073e970fb7492e64b738">err</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">         });</div></div><!-- fragment --><p><code><a class="el" href="structstx_1_1Result.html">Result</a></code> comes with some convenience methods that make working with it more succinct.</p>
<div class="fragment"><div class="line">Result&lt;int, int&gt; good_result = Ok(10);</div><div class="line">Result&lt;int, int&gt; bad_result = Err(10);</div><div class="line"></div><div class="line"><span class="comment">// The `is_ok` and `is_err` methods do what they say.</span></div><div class="line">ASSERT_TRUE(good_result.is_ok() &amp;&amp; !good_result.is_err());</div><div class="line">ASSERT_TRUE(bad_result.is_err() &amp;&amp; !bad_result.is_ok());</div></div><!-- fragment --><p><code><a class="el" href="structstx_1_1Result.html">Result</a></code> is a type that represents either success (<code><a class="el" href="structstx_1_1Ok.html">Ok</a></code>) or failure (<code><a class="el" href="structstx_1_1Err.html">Err</a></code>).</p>
<p><a class="el" href="structstx_1_1Result.html">Result</a> is either in the <a class="el" href="structstx_1_1Ok.html">Ok</a> or <a class="el" href="structstx_1_1Err.html">Err</a> state at any point in time</p>
<h1>Constexpr ?</h1>
<p>C++ 20 and above</p>
<h1>Note</h1>
<p><code><a class="el" href="structstx_1_1Result.html">Result</a></code> unlike <code><a class="el" href="structstx_1_1Option.html">Option</a></code> is a value-forwarding type. It doesn't have copy constructors of any sort. More like a <code>unique_ptr</code>.</p>
<p><code><a class="el" href="structstx_1_1Result.html">Result</a></code> should be seen as a return channel (for returning from functions) and not an object. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a807d28724ecb7c88a1bc71f1f704d06d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a807d28724ecb7c88a1bc71f1f704d06d">&#9670;&nbsp;</a></span>error_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::<a class="el" href="structstx_1_1Result.html#a807d28724ecb7c88a1bc71f1f704d06d">error_type</a> =  E</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a70652ec2d0d23d66d0eb0ed79298171c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70652ec2d0d23d66d0eb0ed79298171c">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::<a class="el" href="structstx_1_1Result.html#a70652ec2d0d23d66d0eb0ed79298171c">value_type</a> =  T</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af95769194b41887e66a5e01cd9f2aba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af95769194b41887e66a5e01cd9f2aba6">&#9670;&nbsp;</a></span>Result() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::<a class="el" href="structstx_1_1Result.html">Result</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1Ok.html">Ok</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a831e2b258f37867f17e5a924017d3edc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a831e2b258f37867f17e5a924017d3edc">&#9670;&nbsp;</a></span>Result() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::<a class="el" href="structstx_1_1Result.html">Result</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1Err.html">Err</a>&lt; E &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>err</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0cb86dae29a262fbbbfd0bfec4c7d8fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cb86dae29a262fbbbfd0bfec4c7d8fa">&#9670;&nbsp;</a></span>Result() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::<a class="el" href="structstx_1_1Result.html">Result</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1Result.html">Result</a>&lt; T, E &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae366d626a55c02884081ef01e34c0566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae366d626a55c02884081ef01e34c0566">&#9670;&nbsp;</a></span>Result() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::<a class="el" href="structstx_1_1Result.html">Result</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a66a498bb326209e5a0c711af6bf13cd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66a498bb326209e5a0c711af6bf13cd0">&#9670;&nbsp;</a></span>Result() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::<a class="el" href="structstx_1_1Result.html">Result</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1Result.html">Result</a>&lt; T, E &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae8669853d99c0bfa4888585b33bc2ee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8669853d99c0bfa4888585b33bc2ee3">&#9670;&nbsp;</a></span>~Result()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8h.html#a01bc9952272b509c21c0aac4a3081c74">STX_CXX20_DESTRUCTOR_CONSTEXPR</a> <a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::~<a class="el" href="structstx_1_1Result.html">Result</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9887983752e7e8e91891ac1600a9c61b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9887983752e7e8e91891ac1600a9c61b">&#9670;&nbsp;</a></span>AND()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<div class="memtemplate">
template&lt;typename U , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::AND </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1Result.html">Result</a>&lt; U, F &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td> &amp;&amp; -&gt; <a class="el" href="structstx_1_1Result.html">Result</a>&lt;U, F&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <code>res</code> if the result is <code><a class="el" href="structstx_1_1Ok.html">Ok</a></code>, otherwise returns the <code><a class="el" href="structstx_1_1Err.html">Err</a></code> value of itself.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line">Result&lt;int, string_view&gt; a = Ok(2);</div><div class="line">Result&lt;string_view, string_view&gt; b = Err(<span class="stringliteral">&quot;late error&quot;</span>sv);</div><div class="line">ASSERT_EQ(move(a).<a class="code" href="structstx_1_1Result.html#a9887983752e7e8e91891ac1600a9c61b">AND</a>(move(b)), Err(<span class="stringliteral">&quot;late error&quot;</span>sv));</div><div class="line"></div><div class="line">Result&lt;int, string_view&gt; c = Err(<span class="stringliteral">&quot;early error&quot;</span>sv);</div><div class="line">Result&lt;string_view, string_view&gt; d = Ok(<span class="stringliteral">&quot;foo&quot;</span>sv);</div><div class="line">ASSERT_EQ(move(c).<a class="code" href="structstx_1_1Result.html#a9887983752e7e8e91891ac1600a9c61b">AND</a>(move(d)), Err(<span class="stringliteral">&quot;early error&quot;</span>sv));</div><div class="line"></div><div class="line">Result&lt;int, string_view&gt; e = Err(<span class="stringliteral">&quot;not a 2&quot;</span>sv);</div><div class="line">Result&lt;string_view, string_view&gt; f = Err(<span class="stringliteral">&quot;late error&quot;</span>sv);</div><div class="line">ASSERT_EQ(move(e).<a class="code" href="structstx_1_1Result.html#a9887983752e7e8e91891ac1600a9c61b">AND</a>(move(f)), Err(<span class="stringliteral">&quot;not a 2&quot;</span>sv));</div><div class="line"></div><div class="line">Result&lt;int, string_view&gt; g = Ok(2);</div><div class="line">Result&lt;string_view, string_view&gt; h = Ok(<span class="stringliteral">&quot;different result type&quot;</span>sv);</div><div class="line">ASSERT_EQ(move(g).<a class="code" href="structstx_1_1Result.html#a9887983752e7e8e91891ac1600a9c61b">AND</a>(move(h)), Ok(<span class="stringliteral">&quot;different result type&quot;</span>sv));</div></div><!-- fragment --> 
</div>
</div>
<a id="a4a93e1bd19b2573c12bec562e54e3085"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a93e1bd19b2573c12bec562e54e3085">&#9670;&nbsp;</a></span>and_then()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::and_then </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> &amp;&amp; -&gt; <a class="el" href="structstx_1_1Result.html">Result</a>&lt;<a class="el" href="namespacestx.html#a2b0a348596751ac8e1ccbe193fad671c">invoke_result</a>&lt;Fn&amp;&amp;, T&amp;&amp;&gt;, E&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calls <code>op</code> if the result is <code><a class="el" href="structstx_1_1Ok.html">Ok</a></code>, otherwise returns the <code><a class="el" href="structstx_1_1Err.html">Err</a></code> value of itself.</p>
<p>This function can be used for control flow based on <code><a class="el" href="structstx_1_1Result.html">Result</a></code> values.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> sq = [](<span class="keywordtype">int</span> x) { <span class="keywordflow">return</span> x * x; };</div><div class="line"></div><div class="line"><span class="keyword">auto</span> <a class="code" href="namespacestx.html#a1754a6b0876636dda571d46f50182507">make_ok</a> = [](<span class="keywordtype">int</span> x) -&gt; Result&lt;int, int&gt; { <span class="keywordflow">return</span> Ok(move(x)); };</div><div class="line"><span class="keyword">auto</span> <a class="code" href="namespacestx.html#aad98263198e88a079235f2845bd1ae09">make_err</a> = [](<span class="keywordtype">int</span> x) -&gt; Result&lt;int, int&gt; { <span class="keywordflow">return</span> Err(move(x)); };</div><div class="line"></div><div class="line">ASSERT_EQ(<a class="code" href="namespacestx.html#a1754a6b0876636dda571d46f50182507">make_ok</a>(2).<a class="code" href="structstx_1_1Result.html#a4a93e1bd19b2573c12bec562e54e3085">and_then</a>(sq).<a class="code" href="structstx_1_1Result.html#a4a93e1bd19b2573c12bec562e54e3085">and_then</a>(sq), Ok(16));</div><div class="line">ASSERT_EQ(<a class="code" href="namespacestx.html#aad98263198e88a079235f2845bd1ae09">make_err</a>(3).<a class="code" href="structstx_1_1Result.html#a4a93e1bd19b2573c12bec562e54e3085">and_then</a>(sq).<a class="code" href="structstx_1_1Result.html#a4a93e1bd19b2573c12bec562e54e3085">and_then</a>(sq), Err(3));</div></div><!-- fragment --> 
</div>
</div>
<a id="a4f0619b2998fe5592a0ed492a1b7cbb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f0619b2998fe5592a0ed492a1b7cbb1">&#9670;&nbsp;</a></span>as_cref() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::as_cref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp; -&gt; <a class="el" href="structstx_1_1Result.html">Result</a>&lt;<a class="el" href="namespacestx.html#ade174634b9a4ee8ee45d74045538b591">ConstRef</a>&lt;T&gt;, <a class="el" href="namespacestx.html#ade174634b9a4ee8ee45d74045538b591">ConstRef</a>&lt;E&gt;&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts from <code><a class="el" href="structstx_1_1Result.html">Result</a>&lt;T, E&gt; &amp;</code> to <code><a class="el" href="structstx_1_1Result.html">Result</a>&lt;ConstRef&lt;T&gt;, ConstRef&lt;E&gt;&gt;</code>.</p>
<p>Produces a new <code><a class="el" href="structstx_1_1Result.html">Result</a></code>, containing an immutable reference into the original, leaving the original in place.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line">Result&lt;int, string&gt; x = Ok(2);</div><div class="line">ASSERT_EQ(x.as_cref().unwrap().get(), 2);</div><div class="line"></div><div class="line">Result&lt;int, string&gt; y = Err(<span class="stringliteral">&quot;Error&quot;</span>s);</div><div class="line">ASSERT_EQ(y.as_cref().unwrap_err().get(), <span class="stringliteral">&quot;Error&quot;</span>s);</div></div><!-- fragment --> 
</div>
</div>
<a id="aef37786f17042833c3d9b6db58c34500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef37786f17042833c3d9b6db58c34500">&#9670;&nbsp;</a></span>as_cref() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::as_cref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;&amp; -&gt;  <a class="el" href="structstx_1_1Result.html">Result</a>&lt; <a class="el" href="namespacestx.html#ade174634b9a4ee8ee45d74045538b591">ConstRef</a>&lt; T &gt;, <a class="el" href="namespacestx.html#ade174634b9a4ee8ee45d74045538b591">ConstRef</a>&lt; E &gt;&gt;=delete</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b1925b08cd1ec54f6096c343d8ead51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b1925b08cd1ec54f6096c343d8ead51">&#9670;&nbsp;</a></span>as_ref() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::as_ref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp; -&gt; <a class="el" href="structstx_1_1Result.html">Result</a>&lt;<a class="el" href="namespacestx.html#a602d285852b6664cc71937407fe7484a">MutRef</a>&lt;T&gt;, <a class="el" href="namespacestx.html#a602d285852b6664cc71937407fe7484a">MutRef</a>&lt;E&gt;&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts from <code><a class="el" href="structstx_1_1Result.html">Result</a>&lt;T, E&gt; &amp;</code> to <code><a class="el" href="structstx_1_1Result.html">Result</a>&lt;MutRef&lt;T&gt;, MutRef&lt;E&gt;&gt;</code>.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> mutate = [](Result&lt;int, int&gt;&amp; r) {</div><div class="line"> r.as_ref().match([](<span class="keyword">auto</span> <a class="code" href="structstx_1_1Result.html#a647e469eda74b8d34a67bab67176b093">ok</a>) { <a class="code" href="structstx_1_1Result.html#a647e469eda74b8d34a67bab67176b093">ok</a>.get() = 42; },</div><div class="line">                  [](<span class="keyword">auto</span> <a class="code" href="structstx_1_1Result.html#a4548a280df6c073e970fb7492e64b738">err</a>) { <a class="code" href="structstx_1_1Result.html#a4548a280df6c073e970fb7492e64b738">err</a>.get() = 0; });</div><div class="line">};</div><div class="line"></div><div class="line">Result&lt;int, int&gt; x = Ok(2);</div><div class="line">mutate(x);</div><div class="line">ASSERT_EQ(x, Ok(42));</div><div class="line"></div><div class="line">Result&lt;int, int&gt; y = Err(13);</div><div class="line">mutate(y);</div><div class="line">ASSERT_EQ(y, Err(0));</div></div><!-- fragment --> 
</div>
</div>
<a id="ad55b4ae46fc26cf60f8f815a0f3e7ab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad55b4ae46fc26cf60f8f815a0f3e7ab1">&#9670;&nbsp;</a></span>as_ref() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::as_ref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp; -&gt; <a class="el" href="structstx_1_1Result.html">Result</a>&lt;<a class="el" href="namespacestx.html#ade174634b9a4ee8ee45d74045538b591">ConstRef</a>&lt;T&gt;, <a class="el" href="namespacestx.html#ade174634b9a4ee8ee45d74045538b591">ConstRef</a>&lt;E&gt;&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acc1cb8410d380de1d614efd23adc2191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc1cb8410d380de1d614efd23adc2191">&#9670;&nbsp;</a></span>as_ref() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::as_ref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp; -&gt;  <a class="el" href="structstx_1_1Result.html">Result</a>&lt; <a class="el" href="namespacestx.html#a602d285852b6664cc71937407fe7484a">MutRef</a>&lt; T &gt;, <a class="el" href="namespacestx.html#a602d285852b6664cc71937407fe7484a">MutRef</a>&lt; E &gt;&gt;=delete</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a73eca146919e60c21d1f829471111111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73eca146919e60c21d1f829471111111">&#9670;&nbsp;</a></span>as_ref() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::as_ref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;&amp; -&gt;  <a class="el" href="structstx_1_1Result.html">Result</a>&lt; <a class="el" href="namespacestx.html#ade174634b9a4ee8ee45d74045538b591">ConstRef</a>&lt; T &gt;, <a class="el" href="namespacestx.html#ade174634b9a4ee8ee45d74045538b591">ConstRef</a>&lt; E &gt;&gt;=delete</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a139eded6af48df1534ecfbc549c821ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a139eded6af48df1534ecfbc549c821ed">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="structstx_1_1Result.html">Result</a>&lt;T, E&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a copy of the result and its contents.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line">Result&lt;int, int&gt; x  = Ok(8);</div><div class="line"></div><div class="line">ASSERT_EQ(x, x.clone());</div></div><!-- fragment --> 
</div>
</div>
<a id="a743fa35a1895e46bb4fa9e74a43987ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a743fa35a1895e46bb4fa9e74a43987ed">&#9670;&nbsp;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<div class="memtemplate">
template&lt;typename CmpType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">CmpType const &amp;&#160;</td>
          <td class="paramname"><em>cmp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <code>true</code> if the result is an <code><a class="el" href="structstx_1_1Ok.html">Ok</a>&lt;T&gt;</code> variant and contains the given value.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line">Result&lt;int, string&gt; x = Ok(2);</div><div class="line">ASSERT_TRUE(x.contains(2));</div><div class="line"></div><div class="line">Result&lt;int, string&gt; y = Ok(3);</div><div class="line">ASSERT_FALSE(y.contains(2));</div><div class="line"></div><div class="line">Result&lt;int, string&gt; z = Err(<span class="stringliteral">&quot;Some error message&quot;</span>s);</div><div class="line">ASSERT_FALSE(z.contains(2));</div></div><!-- fragment --> 
</div>
</div>
<a id="a9ee193c944cd73ae41349f73b8f7d167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ee193c944cd73ae41349f73b8f7d167">&#9670;&nbsp;</a></span>contains_err()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<div class="memtemplate">
template&lt;typename ErrCmp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::contains_err </td>
          <td>(</td>
          <td class="paramtype">ErrCmp const &amp;&#160;</td>
          <td class="paramname"><em>cmp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <code>true</code> if the result is an <code><a class="el" href="structstx_1_1Err.html">Err</a>&lt;E&gt;</code> variant containing the given value.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line">Result&lt;int, string&gt; x = Ok(2);</div><div class="line">ASSERT_FALSE(x.contains_err(<span class="stringliteral">&quot;Some error message&quot;</span>s));</div><div class="line"></div><div class="line">Result&lt;int, string&gt; y = Err(<span class="stringliteral">&quot;Some error message&quot;</span>s);</div><div class="line">ASSERT_TRUE(y.contains_err(<span class="stringliteral">&quot;Some error message&quot;</span>s));</div><div class="line"></div><div class="line">Result&lt;int, string&gt; z = Err(<span class="stringliteral">&quot;Some other error message&quot;</span>s);</div><div class="line">ASSERT_FALSE(z.contains_err(<span class="stringliteral">&quot;Some error message&quot;</span>s));</div></div><!-- fragment --> 
</div>
</div>
<a id="a4548a280df6c073e970fb7492e64b738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4548a280df6c073e970fb7492e64b738">&#9670;&nbsp;</a></span>err()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::err </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp; -&gt; <a class="el" href="structstx_1_1Option.html">Option</a>&lt;E&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts from <code><a class="el" href="structstx_1_1Result.html">Result</a>&lt;T, E&gt;</code> to <code><a class="el" href="structstx_1_1Option.html">Option</a>&lt;E&gt;</code>.</p>
<p>Converts this result into an <code><a class="el" href="structstx_1_1Option.html">Option</a>&lt;E&gt;</code>, consuming itself, and discarding the success value, if any.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line">Result&lt;int, string&gt; x = Ok(2);</div><div class="line">ASSERT_EQ(move(x).<a class="code" href="structstx_1_1Result.html#a4548a280df6c073e970fb7492e64b738">err</a>(), <a class="code" href="namespacestx.html#a5cc62cda4ca89a8ebd4b9fb212fe30c4">None</a>);</div><div class="line"></div><div class="line">Result&lt;int, string&gt; y = Err(<span class="stringliteral">&quot;Nothing here&quot;</span>s);</div><div class="line">ASSERT_EQ(move(y).<a class="code" href="structstx_1_1Result.html#a4548a280df6c073e970fb7492e64b738">err</a>(), Some(<span class="stringliteral">&quot;Nothing here&quot;</span>s));</div></div><!-- fragment --> 
</div>
</div>
<a id="a4ef8e2cc50cb7c4e7579b726115818c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ef8e2cc50cb7c4e7579b726115818c5">&#9670;&nbsp;</a></span>err_exists()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<div class="memtemplate">
template&lt;typename UnaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::err_exists </td>
          <td>(</td>
          <td class="paramtype">UnaryPredicate &amp;&amp;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the value of evaluating the <code>predicate</code> on the contained value if the <code><a class="el" href="structstx_1_1Option.html">Option</a></code> is a <code><a class="el" href="structstx_1_1Some.html">Some</a></code>, else returns <code>false</code>.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line">Result&lt;int, string&gt; x = Err(<span class="stringliteral">&quot;invalid&quot;</span>s);</div><div class="line"><span class="keyword">auto</span> invalid = [](<span class="keyword">auto</span> x) { <span class="keywordflow">return</span> x == <span class="stringliteral">&quot;invalid&quot;</span>; };</div><div class="line"></div><div class="line">ASSERT_TRUE(x.err_exists(invalid));</div></div><!-- fragment --> 
</div>
</div>
<a id="a05656bba7ff00549e0e9aa054e50ad74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05656bba7ff00549e0e9aa054e50ad74">&#9670;&nbsp;</a></span>err_value() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">E&amp; <a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::err_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an l-value reference to the contained error value. Note that no copying occurs here.</p>
<h1>Panics</h1>
<p>Panics if the value is an <code><a class="el" href="structstx_1_1Ok.html">Ok</a></code></p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> result = make_err&lt;int, int&gt;(9);</div><div class="line"><span class="keywordtype">int</span>&amp; <a class="code" href="structstx_1_1Result.html#a4548a280df6c073e970fb7492e64b738">err</a> = result.err_value();</div><div class="line">err = 46;</div><div class="line"></div><div class="line">ASSERT_EQ(result, Err(46));</div></div><!-- fragment --> 
</div>
</div>
<a id="ac951aa045c18bdb6396478b7b6679e33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac951aa045c18bdb6396478b7b6679e33">&#9670;&nbsp;</a></span>err_value() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">E const&amp; <a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::err_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a const l-value reference to the contained error value. Note that no copying occurs here.</p>
<h1>Panics</h1>
<p>Panics if the value is an <code><a class="el" href="structstx_1_1Ok.html">Ok</a></code></p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> <span class="keyword">const</span> result = make_err&lt;int, int&gt;(9);</div><div class="line"><span class="keywordtype">int</span> <span class="keyword">const</span>&amp; err = result.err_value();</div><div class="line"></div><div class="line">ASSERT_EQ(err, 9);</div></div><!-- fragment --> 
</div>
</div>
<a id="a26ce4b1495efaf6e3b5eba80873d78f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26ce4b1495efaf6e3b5eba80873d78f7">&#9670;&nbsp;</a></span>err_value() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">E <a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::err_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use <code><a class="el" href="structstx_1_1Result.html#afe3376a66e7cf9cb15728ba5f4605753">unwrap_err()</a></code> instead. </p>

</div>
</div>
<a id="a1766f844fd7cd69f851dcdf2024aac6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1766f844fd7cd69f851dcdf2024aac6e">&#9670;&nbsp;</a></span>err_value() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">E const <a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::err_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use <code><a class="el" href="structstx_1_1Result.html#afe3376a66e7cf9cb15728ba5f4605753">unwrap_err()</a></code> instead. </p>

</div>
</div>
<a id="a6dfe259de2943c0ec9a906c9fa36de6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dfe259de2943c0ec9a906c9fa36de6b">&#9670;&nbsp;</a></span>exists()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<div class="memtemplate">
template&lt;typename UnaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::exists </td>
          <td>(</td>
          <td class="paramtype">UnaryPredicate &amp;&amp;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the value of evaluating the <code>predicate</code> on the contained value if the <code><a class="el" href="structstx_1_1Option.html">Option</a></code> is a <code><a class="el" href="structstx_1_1Some.html">Some</a></code>, else returns <code>false</code>.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line">Result&lt;int, string&gt; x = Ok(2);</div><div class="line"><span class="keyword">auto</span> even = [](<span class="keyword">auto</span> x) { <span class="keywordflow">return</span> x == 2; };</div><div class="line"></div><div class="line">ASSERT_TRUE(x.exists(even));</div></div><!-- fragment --> 
</div>
</div>
<a id="aa709f0915c320d5a4bbdc8b86889f59c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa709f0915c320d5a4bbdc8b86889f59c">&#9670;&nbsp;</a></span>expect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::expect </td>
          <td>(</td>
          <td class="paramtype">std::string_view const &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td> &amp;&amp; -&gt; T </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unwraps a result, yielding the content of an <code><a class="el" href="structstx_1_1Ok.html">Ok</a></code>.</p>
<h1>Panics</h1>
<p>Panics if the value is an <code><a class="el" href="structstx_1_1Err.html">Err</a></code>, with a panic message including the passed message, and the content of the <code><a class="el" href="structstx_1_1Err.html">Err</a></code>.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line">Result&lt;int, string_view&gt; x = Err(<span class="stringliteral">&quot;emergency failure&quot;</span>sv);</div><div class="line">ASSERT_DEATH(move(x).<a class="code" href="structstx_1_1Result.html#aa709f0915c320d5a4bbdc8b86889f59c">expect</a>(<span class="stringliteral">&quot;Testing expect&quot;</span>));</div></div><!-- fragment --> 
</div>
</div>
<a id="a67298291198a86c4c5342ec581832d71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67298291198a86c4c5342ec581832d71">&#9670;&nbsp;</a></span>expect_err()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::expect_err </td>
          <td>(</td>
          <td class="paramtype">std::string_view const &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td> &amp;&amp; -&gt; E </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unwraps a result, yielding the content of an <code><a class="el" href="structstx_1_1Err.html">Err</a></code>.</p>
<h1>Panics</h1>
<p>Panics if the value is an <code><a class="el" href="structstx_1_1Ok.html">Ok</a></code>, with a panic message including the passed message, and the content of the <code><a class="el" href="structstx_1_1Ok.html">Ok</a></code>.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line">Result&lt;int, string_view&gt; x = Ok(10);</div><div class="line">ASSERT_DEATH(move(x).<a class="code" href="structstx_1_1Result.html#a67298291198a86c4c5342ec581832d71">expect_err</a>(<span class="stringliteral">&quot;Testing expect_err&quot;</span>)); <span class="comment">// panics with</span></div><div class="line">                                                        <span class="comment">// &quot;Testing</span></div><div class="line">                                                        <span class="comment">// expect_err:</span></div><div class="line">                                                        <span class="comment">// 10&quot;</span></div></div><!-- fragment --> 
</div>
</div>
<a id="aa4e5bc1117850786e73e489340443a7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4e5bc1117850786e73e489340443a7c">&#9670;&nbsp;</a></span>is_err()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::is_err </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <code>true</code> if the result is <code><a class="el" href="structstx_1_1Err.html">Err</a>&lt;T&gt;</code>.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line">Result&lt;int, string_view&gt; x = Ok(-3);</div><div class="line">ASSERT_FALSE(x.is_err());</div><div class="line"></div><div class="line">Result&lt;int, string_view&gt; y = Err(<span class="stringliteral">&quot;Some error message&quot;</span>sv);</div><div class="line">ASSERT_TRUE(y.is_err());</div></div><!-- fragment --> 
</div>
</div>
<a id="aed6b8a1eb140d1109fb47f2f9176e472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed6b8a1eb140d1109fb47f2f9176e472">&#9670;&nbsp;</a></span>is_ok()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::is_ok </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <code>true</code> if the result is an <code><a class="el" href="structstx_1_1Ok.html">Ok</a>&lt;T&gt;</code> variant.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line">Result&lt;int, string_view&gt; x = Ok(-3);</div><div class="line">ASSERT_TRUE(x.is_ok());</div><div class="line"></div><div class="line">Result&lt;int, string_view&gt; y = Err(<span class="stringliteral">&quot;Some error message&quot;</span>sv);</div><div class="line">ASSERT_FALSE(y.is_ok());</div></div><!-- fragment --> 
</div>
</div>
<a id="a71265ef5f49701229cbc55fd6dd1a907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71265ef5f49701229cbc55fd6dd1a907">&#9670;&nbsp;</a></span>map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::map </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> &amp;&amp; -&gt; <a class="el" href="structstx_1_1Result.html">Result</a>&lt;<a class="el" href="namespacestx.html#a2b0a348596751ac8e1ccbe193fad671c">invoke_result</a>&lt;Fn&amp;&amp;, T&amp;&amp;&gt;, E&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Maps a <code><a class="el" href="structstx_1_1Result.html">Result</a>&lt;T, E&gt;</code> to <code><a class="el" href="structstx_1_1Result.html">Result</a>&lt;U, E&gt;</code> by applying the function <code>op</code> to the contained <code><a class="el" href="structstx_1_1Ok.html">Ok</a>&lt;T&gt;</code> value, leaving an <code><a class="el" href="structstx_1_1Err.html">Err</a>&lt;E&gt;</code> value untouched.</p>
<p>This function can be used to compose the results of two functions.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<p>Extract the content-type from an http header</p>
<div class="fragment"><div class="line"><span class="keyword">enum class</span> Error { InvalidHeader };</div><div class="line"><span class="keyword">auto</span> header = <span class="stringliteral">&quot;Content-Type: multipart/form-data&quot;</span>sv;</div><div class="line"></div><div class="line"><span class="keyword">auto</span> check_header = [](string_view s) -&gt; Result&lt;string_view, Error&gt; {</div><div class="line"> <span class="keywordflow">if</span> (!s.starts_with(<span class="stringliteral">&quot;Content-Type: &quot;</span>sv)) <span class="keywordflow">return</span> Err(Error::InvalidHeader);</div><div class="line"> <span class="keywordflow">return</span> Ok(move(s));</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">auto</span> content_type =</div><div class="line">check_header(header).map([](<span class="keyword">auto</span> s) { <span class="keywordflow">return</span> s.substr(14); });</div><div class="line"></div><div class="line">ASSERT_EQ(content_type, Ok(<span class="stringliteral">&quot;multipart/form-data&quot;</span>sv));</div></div><!-- fragment --> 
</div>
</div>
<a id="a7386c27d672f57dfcb00e26f873cc5b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7386c27d672f57dfcb00e26f873cc5b3">&#9670;&nbsp;</a></span>map_err()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::map_err </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> &amp;&amp; -&gt; <a class="el" href="structstx_1_1Result.html">Result</a>&lt;T, <a class="el" href="namespacestx.html#a2b0a348596751ac8e1ccbe193fad671c">invoke_result</a>&lt;Fn&amp;&amp;, E&amp;&amp;&gt;&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Maps a <code><a class="el" href="structstx_1_1Result.html">Result</a>&lt;T, E&gt;</code> to <code><a class="el" href="structstx_1_1Result.html">Result</a>&lt;T, F&gt;</code> by applying a function to a contained <code><a class="el" href="structstx_1_1Err.html">Err</a></code> value, leaving an <code><a class="el" href="structstx_1_1Ok.html">Ok</a></code> value untouched.</p>
<p>This function can be used to pass through a successful result while handling an error.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> stringify = [](<span class="keyword">auto</span> x) { <span class="keywordflow">return</span> <span class="stringliteral">&quot;error code: &quot;</span> + std::to_string(x);</div><div class="line">};</div><div class="line"></div><div class="line">Result&lt;int, int&gt; x = Ok(2);</div><div class="line">ASSERT_EQ(move(x).<a class="code" href="structstx_1_1Result.html#a7386c27d672f57dfcb00e26f873cc5b3">map_err</a>(stringify), Ok(2));</div><div class="line"></div><div class="line">Result&lt;int, int&gt; y = Err(404);</div><div class="line">ASSERT_EQ(move(y).<a class="code" href="structstx_1_1Result.html#a7386c27d672f57dfcb00e26f873cc5b3">map_err</a>(stringify), Err(<span class="stringliteral">&quot;error code: 404&quot;</span>s));</div></div><!-- fragment --> 
</div>
</div>
<a id="a1780132ed87f65a5241c929b303389ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1780132ed87f65a5241c929b303389ce">&#9670;&nbsp;</a></span>map_or()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<div class="memtemplate">
template&lt;typename Fn , typename AltType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::map_or </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AltType &amp;&amp;&#160;</td>
          <td class="paramname"><em>alt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> &amp;&amp; -&gt; <a class="el" href="namespacestx.html#a2b0a348596751ac8e1ccbe193fad671c">invoke_result</a>&lt;Fn&amp;&amp;, T&amp;&amp;&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies a function to the contained value (if any), or returns the provided default (if not).</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line">Result&lt;string, int&gt; x = Ok(<span class="stringliteral">&quot;foo&quot;</span>s);</div><div class="line"><span class="keyword">auto</span> map_fn = [](<span class="keyword">auto</span> s) { <span class="keywordflow">return</span> s.size(); };</div><div class="line">ASSERT_EQ(move(x).<a class="code" href="structstx_1_1Result.html#a1780132ed87f65a5241c929b303389ce">map_or</a>(map_fn, 42UL), 3UL);</div><div class="line"></div><div class="line">Result&lt;string, int&gt; y = Err(-404);</div><div class="line">ASSERT_EQ(move(y).<a class="code" href="structstx_1_1Result.html#a1780132ed87f65a5241c929b303389ce">map_or</a>(map_fn, 42UL), 42UL);</div></div><!-- fragment --> 
</div>
</div>
<a id="a33ebb51c333a68c37c04e322657f29be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33ebb51c333a68c37c04e322657f29be">&#9670;&nbsp;</a></span>map_or_else()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<div class="memtemplate">
template&lt;typename Fn , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::map_or_else </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>alt_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> &amp;&amp; -&gt; <a class="el" href="namespacestx.html#a2b0a348596751ac8e1ccbe193fad671c">invoke_result</a>&lt;Fn&amp;&amp;, T&amp;&amp;&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Maps a <code><a class="el" href="structstx_1_1Result.html">Result</a>&lt;T, E&gt;</code> to <code>U</code> by applying a function to a contained <code><a class="el" href="structstx_1_1Ok.html">Ok</a></code> value, or a fallback function to a contained <code><a class="el" href="structstx_1_1Err.html">Err</a></code> value.</p>
<p>This function can be used to unpack a successful result while handling an error.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><span class="keywordtype">size_t</span> <span class="keyword">const</span> k = 21;</div><div class="line"></div><div class="line">Result&lt;string_view, size_t&gt; x = Ok(<span class="stringliteral">&quot;foo&quot;</span>sv);</div><div class="line"><span class="keyword">auto</span> map_fn = [](<span class="keyword">auto</span> s) { <span class="keywordflow">return</span> s.size(); };</div><div class="line"><span class="keyword">auto</span> else_fn = [&amp;](<span class="keyword">auto</span>) { <span class="keywordflow">return</span> k * 2UL; };</div><div class="line"></div><div class="line">ASSERT_EQ(move(x).<a class="code" href="structstx_1_1Result.html#a33ebb51c333a68c37c04e322657f29be">map_or_else</a>(map_fn, else_fn), 3);</div><div class="line"></div><div class="line">Result&lt;string_view, size_t&gt; y = Err(404UL);</div><div class="line">ASSERT_EQ(move(y).<a class="code" href="structstx_1_1Result.html#a33ebb51c333a68c37c04e322657f29be">map_or_else</a>(map_fn, else_fn), 42);</div></div><!-- fragment --> 
</div>
</div>
<a id="aead72098ed0268c631b45aed236c4c67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aead72098ed0268c631b45aed236c4c67">&#9670;&nbsp;</a></span>match() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<div class="memtemplate">
template&lt;typename OkFn , typename ErrFn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::match </td>
          <td>(</td>
          <td class="paramtype">OkFn &amp;&amp;&#160;</td>
          <td class="paramname"><em>ok_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ErrFn &amp;&amp;&#160;</td>
          <td class="paramname"><em>err_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> &amp;&amp; -&gt; <a class="el" href="namespacestx.html#a2b0a348596751ac8e1ccbe193fad671c">invoke_result</a>&lt;OkFn&amp;&amp;, T&amp;&amp;&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calls the parameter <code>ok_fn</code> with the value if this result is an <code><a class="el" href="structstx_1_1Ok.html">Ok</a>&lt;T&gt;</code>, else calls <code>err_fn</code> with the error. This result is consumed afterward.</p>
<p>The return type of both parameters must be convertible. They can also both return nothing ( <code>void</code> ).</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> i = make_ok&lt;int, string_view&gt;(99);</div><div class="line"></div><div class="line"><span class="keyword">auto</span> j = move(i).match([](<span class="keywordtype">int</span> value) { <span class="keywordflow">return</span> <a class="code" href="structstx_1_1Result.html#a00c0c5eaa92721eb93ac36733bc8efc9">value</a>; },</div><div class="line">                       [](string_view) { <span class="keywordflow">return</span> -1; });</div><div class="line">ASSERT_EQ(j, 99);</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">auto</span> x = make_err&lt;int, string_view&gt;(<span class="stringliteral">&quot;404 Not Found&quot;</span>sv);</div><div class="line"><span class="comment">// you can return nothing (void)</span></div><div class="line">x.match([](<span class="keywordtype">int</span>&amp;) {},</div><div class="line">        [](string_view&amp; s) { std::cout &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; s &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>; });</div></div><!-- fragment --><h1>Notes</h1>
<ul>
<li>The <code><a class="el" href="structstx_1_1Result.html">Result</a></code>'s reference type is passed to the function arguments. i.e. If the <code><a class="el" href="structstx_1_1Result.html">Result</a></code> is an r-value, r-value references are passed to the function arguments <code>some_fn</code> and <code>none_fn</code>. </li>
</ul>

</div>
</div>
<a id="a1c70c18b27a77c3c2f350a07c8fac535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c70c18b27a77c3c2f350a07c8fac535">&#9670;&nbsp;</a></span>match() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<div class="memtemplate">
template&lt;typename OkFn , typename ErrFn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::match </td>
          <td>(</td>
          <td class="paramtype">OkFn &amp;&amp;&#160;</td>
          <td class="paramname"><em>ok_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ErrFn &amp;&amp;&#160;</td>
          <td class="paramname"><em>err_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> &amp; -&gt; <a class="el" href="namespacestx.html#a2b0a348596751ac8e1ccbe193fad671c">invoke_result</a>&lt;OkFn&amp;&amp;, T&amp;&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f1a62bac55d1617b22a5d027fadc799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f1a62bac55d1617b22a5d027fadc799">&#9670;&nbsp;</a></span>match() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<div class="memtemplate">
template&lt;typename OkFn , typename ErrFn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::match </td>
          <td>(</td>
          <td class="paramtype">OkFn &amp;&amp;&#160;</td>
          <td class="paramname"><em>ok_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ErrFn &amp;&amp;&#160;</td>
          <td class="paramname"><em>err_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const &amp; -&gt; <a class="el" href="namespacestx.html#a2b0a348596751ac8e1ccbe193fad671c">invoke_result</a>&lt;OkFn&amp;&amp;, T const&amp;&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a647e469eda74b8d34a67bab67176b093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a647e469eda74b8d34a67bab67176b093">&#9670;&nbsp;</a></span>ok()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::ok </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp; -&gt; <a class="el" href="structstx_1_1Option.html">Option</a>&lt;T&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts from <code><a class="el" href="structstx_1_1Result.html">Result</a>&lt;T, E&gt;</code> to <code><a class="el" href="structstx_1_1Option.html">Option</a>&lt;T&gt;</code>.</p>
<p>Converts this result into an <code><a class="el" href="structstx_1_1Option.html">Option</a>&lt;T&gt;</code>, consuming itself, and discarding the error, if any.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line">Result&lt;int, string&gt; x = Ok(2);</div><div class="line">ASSERT_EQ(move(x).<a class="code" href="structstx_1_1Result.html#a647e469eda74b8d34a67bab67176b093">ok</a>(), Some(2));</div><div class="line"></div><div class="line">Result&lt;int, string&gt; y = Err(<span class="stringliteral">&quot;Nothing here&quot;</span>s);</div><div class="line">ASSERT_EQ(move(y).<a class="code" href="structstx_1_1Result.html#a647e469eda74b8d34a67bab67176b093">ok</a>(), <a class="code" href="namespacestx.html#a5cc62cda4ca89a8ebd4b9fb212fe30c4">None</a>);</div></div><!-- fragment --> 
</div>
</div>
<a id="ad8e1a44d243ec4fef0f9c26745502fe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8e1a44d243ec4fef0f9c26745502fe4">&#9670;&nbsp;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aedcc0e4a2cc5439b6fd77ecc5a9376cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedcc0e4a2cc5439b6fd77ecc5a9376cb">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1Ok.html">Ok</a>&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>cmp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aae52952aff96f046e1a570b2eb67f1f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae52952aff96f046e1a570b2eb67f1f8">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1Err.html">Err</a>&lt; F &gt; const &amp;&#160;</td>
          <td class="paramname"><em>cmp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aacc3bce74f36e67d45f00758f925e855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacc3bce74f36e67d45f00758f925e855">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<div class="memtemplate">
template&lt;typename U , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1Result.html">Result</a>&lt; U, F &gt; const &amp;&#160;</td>
          <td class="paramname"><em>cmp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abf7163cffd3c4ab4b12ebdf8d3e43524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf7163cffd3c4ab4b12ebdf8d3e43524">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstx_1_1Result.html">Result</a>&amp; <a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1Result.html">Result</a>&lt; T, E &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="accce70e349246b1a291b34d4a4ba80e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accce70e349246b1a291b34d4a4ba80e1">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstx_1_1Result.html">Result</a>&amp; <a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1Result.html">Result</a>&lt; T, E &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a844857a60f90469516096a08ed1d211e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a844857a60f90469516096a08ed1d211e">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1Ok.html">Ok</a>&lt; U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>cmp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac803618a310ed1de10f9a5e7717d8373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac803618a310ed1de10f9a5e7717d8373">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1Err.html">Err</a>&lt; F &gt; const &amp;&#160;</td>
          <td class="paramname"><em>cmp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2470723a0a84fbeaf22c0300aed795f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2470723a0a84fbeaf22c0300aed795f0">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<div class="memtemplate">
template&lt;typename U , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1Result.html">Result</a>&lt; U, F &gt; const &amp;&#160;</td>
          <td class="paramname"><em>cmp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af6e9056581c7bc9abe15641e0d15a46c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6e9056581c7bc9abe15641e0d15a46c">&#9670;&nbsp;</a></span>OR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<div class="memtemplate">
template&lt;typename U , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::OR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1Result.html">Result</a>&lt; U, F &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>alt</em></td><td>)</td>
          <td> &amp;&amp; -&gt; <a class="el" href="structstx_1_1Result.html">Result</a>&lt;U, F&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <code>res</code> if the result is <code><a class="el" href="structstx_1_1Err.html">Err</a></code>, otherwise returns the <code><a class="el" href="structstx_1_1Ok.html">Ok</a></code> value of itself.</p>
<p>Arguments passed to <code>or</code> are eagerly evaluated; if you are passing the result of a function call, it is recommended to use <code>or_else</code>, which is lazily evaluated.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line">Result&lt;int, string_view&gt; a = Ok(2);</div><div class="line">Result&lt;int, string_view&gt; b = Err(<span class="stringliteral">&quot;late error&quot;</span>sv);</div><div class="line">ASSERT_EQ(move(a).<a class="code" href="structstx_1_1Result.html#af6e9056581c7bc9abe15641e0d15a46c">OR</a>(move(b)), Ok(2));</div><div class="line"></div><div class="line">Result&lt;int, string_view&gt; c = Err(<span class="stringliteral">&quot;early error&quot;</span>sv);</div><div class="line">Result&lt;int, string_view&gt; d = Ok(2);</div><div class="line">ASSERT_EQ(move(c).<a class="code" href="structstx_1_1Result.html#af6e9056581c7bc9abe15641e0d15a46c">OR</a>(move(d)), Ok(2));</div><div class="line"></div><div class="line">Result&lt;int, string_view&gt; e = Err(<span class="stringliteral">&quot;not a 2&quot;</span>sv);</div><div class="line">Result&lt;int, string_view&gt; f = Err(<span class="stringliteral">&quot;late error&quot;</span>sv);</div><div class="line">ASSERT_EQ(move(e).<a class="code" href="structstx_1_1Result.html#af6e9056581c7bc9abe15641e0d15a46c">OR</a>(move(f)), Err(<span class="stringliteral">&quot;late error&quot;</span>sv));</div><div class="line"></div><div class="line">Result&lt;int, string_view&gt; g = Ok(2);</div><div class="line">Result&lt;int, string_view&gt; h = Ok(100);</div><div class="line">ASSERT_EQ(move(g).<a class="code" href="structstx_1_1Result.html#af6e9056581c7bc9abe15641e0d15a46c">OR</a>(move(h)), Ok(2));</div></div><!-- fragment --> 
</div>
</div>
<a id="a03224a84bce88eeec3c5858eeed53893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03224a84bce88eeec3c5858eeed53893">&#9670;&nbsp;</a></span>or_else()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::or_else </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> &amp;&amp; -&gt; <a class="el" href="namespacestx.html#a2b0a348596751ac8e1ccbe193fad671c">invoke_result</a>&lt;Fn&amp;&amp;, E&amp;&amp;&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calls <code>op</code> if the result is <code><a class="el" href="structstx_1_1Err.html">Err</a></code>, otherwise returns the <code><a class="el" href="structstx_1_1Ok.html">Ok</a></code> value of itself.</p>
<p>This function can be used for control flow based on result values.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> <a class="code" href="namespacestx.html#a1754a6b0876636dda571d46f50182507">make_ok</a> = [](<span class="keywordtype">int</span> x) -&gt; Result&lt;int, int&gt; { <span class="keywordflow">return</span> Ok(move(x)); };</div><div class="line"><span class="keyword">auto</span> <a class="code" href="namespacestx.html#aad98263198e88a079235f2845bd1ae09">make_err</a> = [](<span class="keywordtype">int</span> x) -&gt; Result&lt;int, int&gt; { <span class="keywordflow">return</span> Err(move(x)); };</div><div class="line"><span class="keyword">auto</span> sq = [](<span class="keywordtype">int</span> <a class="code" href="structstx_1_1Result.html#a4548a280df6c073e970fb7492e64b738">err</a>) -&gt; Result&lt;int, int&gt; { <span class="keywordflow">return</span> Ok(err * err); };</div><div class="line"><span class="keyword">auto</span> err = [](<span class="keywordtype">int</span> <a class="code" href="structstx_1_1Result.html#a4548a280df6c073e970fb7492e64b738">err</a>) -&gt; Result&lt;int, int&gt; { <span class="keywordflow">return</span> Err(move(err)); };</div><div class="line"></div><div class="line">ASSERT_EQ(<a class="code" href="namespacestx.html#a1754a6b0876636dda571d46f50182507">make_ok</a>(2).<a class="code" href="structstx_1_1Result.html#a03224a84bce88eeec3c5858eeed53893">or_else</a>(sq).<a class="code" href="structstx_1_1Result.html#a03224a84bce88eeec3c5858eeed53893">or_else</a>(sq), Ok(2));</div><div class="line">ASSERT_EQ(<a class="code" href="namespacestx.html#a1754a6b0876636dda571d46f50182507">make_ok</a>(2).<a class="code" href="structstx_1_1Result.html#a03224a84bce88eeec3c5858eeed53893">or_else</a>(err).<a class="code" href="structstx_1_1Result.html#a03224a84bce88eeec3c5858eeed53893">or_else</a>(sq), Ok(2));</div><div class="line">ASSERT_EQ(<a class="code" href="namespacestx.html#aad98263198e88a079235f2845bd1ae09">make_err</a>(3).<a class="code" href="structstx_1_1Result.html#a03224a84bce88eeec3c5858eeed53893">or_else</a>(sq).<a class="code" href="structstx_1_1Result.html#a03224a84bce88eeec3c5858eeed53893">or_else</a>(err), Ok(9));</div><div class="line">ASSERT_EQ(<a class="code" href="namespacestx.html#aad98263198e88a079235f2845bd1ae09">make_err</a>(3).<a class="code" href="structstx_1_1Result.html#a03224a84bce88eeec3c5858eeed53893">or_else</a>(err).<a class="code" href="structstx_1_1Result.html#a03224a84bce88eeec3c5858eeed53893">or_else</a>(err), Err(3));</div></div><!-- fragment --> 
</div>
</div>
<a id="a8214d8b604e553a0c4e8780b1dcc45d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8214d8b604e553a0c4e8780b1dcc45d6">&#9670;&nbsp;</a></span>unwrap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::unwrap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp; -&gt; T </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unwraps a result, yielding the content of an <code><a class="el" href="structstx_1_1Ok.html">Ok</a></code>.</p>
<h1>Panics</h1>
<p>Panics if the value is an <code><a class="el" href="structstx_1_1Err.html">Err</a></code>, with a panic message provided by the <code><a class="el" href="structstx_1_1Err.html">Err</a></code>'s value.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line">ASSERT_EQ(make_ok&lt;int, string_view&gt;(2).<a class="code" href="structstx_1_1Result.html#a8214d8b604e553a0c4e8780b1dcc45d6">unwrap</a>(), 2);</div><div class="line">Result&lt;int, string_view&gt; x = Err(<span class="stringliteral">&quot;emergency failure&quot;</span>sv);</div><div class="line">ASSERT_DEATH(move(x).<a class="code" href="structstx_1_1Result.html#a8214d8b604e553a0c4e8780b1dcc45d6">unwrap</a>());</div></div><!-- fragment --> 
</div>
</div>
<a id="afe3376a66e7cf9cb15728ba5f4605753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe3376a66e7cf9cb15728ba5f4605753">&#9670;&nbsp;</a></span>unwrap_err()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::unwrap_err </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp; -&gt; E </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unwraps a result, yielding the content of an <code><a class="el" href="structstx_1_1Err.html">Err</a></code>.</p>
<h1>Panics</h1>
<p>Panics if the value is an <code><a class="el" href="structstx_1_1Ok.html">Ok</a></code>, with a custom panic message provided by the <code><a class="el" href="structstx_1_1Ok.html">Ok</a></code>'s value.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line">Result&lt;int, string_view&gt; x = Ok(2);</div><div class="line">ASSERT_DEATH(move(x).<a class="code" href="structstx_1_1Result.html#afe3376a66e7cf9cb15728ba5f4605753">unwrap_err</a>()); <span class="comment">// panics</span></div><div class="line"></div><div class="line">Result&lt;int, string_view&gt; y = Err(<span class="stringliteral">&quot;emergency failure&quot;</span>sv);</div><div class="line">ASSERT_EQ(move(y).<a class="code" href="structstx_1_1Result.html#afe3376a66e7cf9cb15728ba5f4605753">unwrap_err</a>(), <span class="stringliteral">&quot;emergency failure&quot;</span>);</div></div><!-- fragment --> 
</div>
</div>
<a id="a64ce9a41c7dcdfc6283e33783836cd89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64ce9a41c7dcdfc6283e33783836cd89">&#9670;&nbsp;</a></span>unwrap_or()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::unwrap_or </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>alt</em></td><td>)</td>
          <td> &amp;&amp; -&gt; T </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unwraps a result, yielding the content of an <code><a class="el" href="structstx_1_1Ok.html">Ok</a>&lt;T&gt;</code> variant. Else, it returns the parameter <code>alt</code>.</p>
<p>Arguments passed to <code>unwrap_or</code> are eagerly evaluated; if you are passing the result of a function call, it is recommended to use <code>unwrap_or_else</code>, which is lazily evaluated.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> alt = 2;</div><div class="line">Result&lt;int, string_view&gt; x = Ok(9);</div><div class="line">ASSERT_EQ(move(x).<a class="code" href="structstx_1_1Result.html#a64ce9a41c7dcdfc6283e33783836cd89">unwrap_or</a>(move(alt)), 9);</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> alt_b = 2;</div><div class="line">Result&lt;int, string_view&gt; y = Err(<span class="stringliteral">&quot;error&quot;</span>sv);</div><div class="line">ASSERT_EQ(move(y).<a class="code" href="structstx_1_1Result.html#a64ce9a41c7dcdfc6283e33783836cd89">unwrap_or</a>(move(alt_b)), 2);</div></div><!-- fragment --> 
</div>
</div>
<a id="a459cf27df4dea1f677ee533c3dbec9fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a459cf27df4dea1f677ee533c3dbec9fd">&#9670;&nbsp;</a></span>unwrap_or_default()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::unwrap_or_default </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp; -&gt; T </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the contained value or a default</p>
<p>Consumes itself then, if <code><a class="el" href="structstx_1_1Ok.html">Ok</a></code>, returns the contained value, otherwise if <code><a class="el" href="structstx_1_1Err.html">Err</a></code>, returns the default value for that type.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line">Result&lt;string, int&gt; good_year = Ok(<span class="stringliteral">&quot;1909&quot;</span>s);</div><div class="line">Result&lt;string, int&gt; bad_year = Err(-1);</div><div class="line"></div><div class="line">ASSERT_EQ(move(good_year).<a class="code" href="structstx_1_1Result.html#a459cf27df4dea1f677ee533c3dbec9fd">unwrap_or_default</a>(), <span class="stringliteral">&quot;1909&quot;</span>s);</div><div class="line">ASSERT_EQ(move(bad_year).<a class="code" href="structstx_1_1Result.html#a459cf27df4dea1f677ee533c3dbec9fd">unwrap_or_default</a>(), <span class="stringliteral">&quot;&quot;</span>s); <span class="comment">// empty string (&quot;&quot;s)</span></div><div class="line">                                                    <span class="comment">// is the default</span></div><div class="line">                                                    <span class="comment">// value</span></div><div class="line">                                                    <span class="comment">// for a C++ string</span></div></div><!-- fragment --> 
</div>
</div>
<a id="a7576a636cf6f36b53353eaea67252ad4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7576a636cf6f36b53353eaea67252ad4">&#9670;&nbsp;</a></span>unwrap_or_else()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::unwrap_or_else </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> &amp;&amp; -&gt; T </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unwraps a result, yielding the content of an <code><a class="el" href="structstx_1_1Ok.html">Ok</a></code>. If the value is an <code><a class="el" href="structstx_1_1Err.html">Err</a></code> then it calls <code>op</code> with its value.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> count = [] (string_view <a class="code" href="structstx_1_1Result.html#a4548a280df6c073e970fb7492e64b738">err</a>)  { <span class="keywordflow">return</span> err.size(); };</div><div class="line"></div><div class="line">ASSERT_EQ(make_ok&lt;size_t,string_view&gt;(2UL).<a class="code" href="structstx_1_1Result.html#a7576a636cf6f36b53353eaea67252ad4">unwrap_or_else</a>(count), 2);</div><div class="line">ASSERT_EQ(make_err&lt;size_t,string_view&gt;(<span class="stringliteral">&quot;booo&quot;</span>sv).<a class="code" href="structstx_1_1Result.html#a7576a636cf6f36b53353eaea67252ad4">unwrap_or_else</a>(count),</div><div class="line">4);</div></div><!-- fragment --> 
</div>
</div>
<a id="a00c0c5eaa92721eb93ac36733bc8efc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00c0c5eaa92721eb93ac36733bc8efc9">&#9670;&nbsp;</a></span>value() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an l-value reference to the contained value. Note that no copying occurs here.</p>
<h1>Panics</h1>
<p>Panics if the value is an <code><a class="el" href="structstx_1_1Err.html">Err</a></code></p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> result = make_ok&lt;int, int&gt;(6);</div><div class="line"><span class="keywordtype">int</span>&amp; value = result.value();</div><div class="line">value = 97;</div><div class="line"></div><div class="line">ASSERT_EQ(result, Ok(97));</div></div><!-- fragment --> 
</div>
</div>
<a id="acc665cf1430c9e91a13931fe4681460a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc665cf1430c9e91a13931fe4681460a">&#9670;&nbsp;</a></span>value() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T const&amp; <a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an l-value reference to the contained value. Note that no copying occurs here.</p>
<h1>Panics</h1>
<p>Panics if the value is an <code><a class="el" href="structstx_1_1Err.html">Err</a></code></p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> <span class="keyword">const</span> result = make_ok&lt;int, int&gt;(6);</div><div class="line"><span class="keywordtype">int</span> <span class="keyword">const</span>&amp; value = result.value();</div><div class="line"></div><div class="line">ASSERT_EQ(value, 6);</div></div><!-- fragment --> 
</div>
</div>
<a id="ae844f3dbacf73f29b78957abeefb85c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae844f3dbacf73f29b78957abeefb85c0">&#9670;&nbsp;</a></span>value() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use <code><a class="el" href="structstx_1_1Result.html#a8214d8b604e553a0c4e8780b1dcc45d6">unwrap()</a></code> instead. </p>

</div>
</div>
<a id="a4baa7aea8724b017437bce47b7023ff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4baa7aea8724b017437bce47b7023ff8">&#9670;&nbsp;</a></span>value() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T const <a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use <code><a class="el" href="structstx_1_1Result.html#a8214d8b604e553a0c4e8780b1dcc45d6">unwrap()</a></code> instead. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a386e3f646df41ee88aeb5ad882aef6be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a386e3f646df41ee88aeb5ad882aef6be">&#9670;&nbsp;</a></span>internal::result::unsafe_err_move</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<div class="memtemplate">
template&lt;typename Tp , typename Er &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Er&amp;&amp; <a class="el" href="namespacestx_1_1internal_1_1result.html#a235966bbcc1e1ed3421ddc1ba4358538">internal::result::unsafe_err_move</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1Result.html">Result</a>&lt; Tp, Er &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2eda88a2d2a39f4dff5f7aa43fa3e612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eda88a2d2a39f4dff5f7aa43fa3e612">&#9670;&nbsp;</a></span>internal::result::unsafe_value_move</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<div class="memtemplate">
template&lt;typename Tp , typename Er &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Tp&amp;&amp; <a class="el" href="namespacestx_1_1internal_1_1result.html#a7ec2b4bdb117683ffe736a20c7814880">internal::result::unsafe_value_move</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1Result.html">Result</a>&lt; Tp, Er &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a24227aa96985cfaaa535c6d7946b6b0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24227aa96985cfaaa535c6d7946b6b0c">&#9670;&nbsp;</a></span>storage_err_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">E <a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::storage_err_</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5a38add5b6bf271988836bc4a212434e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a38add5b6bf271988836bc4a212434e">&#9670;&nbsp;</a></span>storage_value_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="structstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::storage_value_</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>include/stx/internal/<a class="el" href="option__result_8h_source.html">option_result.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer" />
<address class="footer"><small>
    Generated by &#160;<a href="http://www.doxygen.org/index.html"> Doxygen
    </a> 1.8.13
  </small></address>
<script type="text/javascript">
  (() => {
    document.body.onload = (() => {
      //
      //
      let clipboard_icon = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"\
      class="copy-icon dimming-wrap">\
      <path d="M0 0h24v24H0z"  fill="none"/>\
      <path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 \
      2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/>\
      </svg>';
      for (let x of document.querySelectorAll("div.fragment")) {
        if (x.querySelector(".lineno") == null)
          x.innerHTML = clipboard_icon + x.innerHTML;
      };
      for (let copy_icon of document.querySelectorAll(".copy-icon")) {
        copy_icon.onclick = () => {
          let code_content = "";
          for (let line of copy_icon.parentElement.querySelectorAll(".line")) {
            code_content = code_content.concat(line.textContent);
            code_content = code_content.concat("\n");
          }
          navigator.clipboard.writeText(code_content);
          alert("Copied to Clipboard");
        };
      };
    });
  })();
</script>
</body>
</html>