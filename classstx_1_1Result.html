<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=9" />
    <meta name="generator" content="Doxygen 1.8.13" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>STX: stx::Result&lt; T, E &gt; Class Template Reference</title>
    <link href="tabs.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <link href="styles.css" rel="stylesheet" type="text/css" />
</head>
<body>
    <script>
        /*
                // light mode, dark mode
                color: ["#333", "#DDD"],
                backgroundColor: ["#FFFFFF", "#353535"],
                cardBackgroundColor: ["#F5F5F5", "#2A2A2A"],
                linkColor: ["#3D578C", "#D2991D"],
                headerBackgroundColor: ["#F1F1F1", "#505050"],
                headerHoverBackgroundColor: ["#F5F5F5", "#444"],
                // memtitle, memproto, memitemleft, memitemright 
                docprotoBackgroundColor: ["#FAFAFA", "2A2A2A"]
        */
        function switchTheme() {
            let theme = localStorage.getItem("theme");
            if (theme == "light" || theme == null) {
                document.body.className = "dark-theme";
                localStorage.setItem("theme", "dark");
            } else {
                document.body.className = "";
                localStorage.setItem("theme", "light");
            }
        }
        (function loadTheme() {
            let theme = localStorage.getItem("theme");
            console.log("theme:" + theme);
            if (theme == "light" || theme == null) {
                document.body.className = "";
            } else {
                document.body.className = "dark-theme";
            }
        })();
    </script>
    <div class="theme-switch dimming-wrap" onclick="switchTheme()">
        <div>
            <svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 48 48">
                <path
                    d="M42 6H6c-2.21 0-4 1.79-4 4v28c0 2.21 1.79 4 4 4h36c2.21 0 4-1.79 4-4V10c0-2.21-1.79-4-4-4zm0 32.03H6V9.97h36v28.06zM16 32h5l3 3 3-3h5v-5l3-3-3-3v-5h-5l-3-3-3 3h-5v5l-3 3 3 3v5zm8-14c3.31 0 6 2.69 6 6s-2.69 6-6 6V18z" />
            </svg></div>
    </div>
    <div id="top">
        <!-- do not remove this div, it is closed by doxygen! -->
        <div id="titlearea">
            <table cellspacing="0" cellpadding="0">
                <tbody>
                    <tr style="height: 56px;">
                        <td id="projectlogo"><img alt="Logo"
                                src="eagle.png" /></td>
                        <td id="projectalign" style="padding-left: 0.5em;">
                            <div id="projectname"> STX
                            </div>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
        <!-- end header part --><!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacestx.html">stx</a></li><li class="navelem"><a class="el" href="classstx_1_1Result.html">Result</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classstx_1_1Result-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">stx::Result&lt; T, E &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="option__result_8h_source.html">option_result.h</a>&gt;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;Swappable T, Swappable E&gt;<br />
class stx::Result&lt; T, E &gt;</h3>

<h3>Error handling with the <code><a class="el" href="classstx_1_1Result.html">Result</a></code> type.</h3>
<p><code><a class="el" href="classstx_1_1Result.html">Result</a>&lt;T, E&gt;</code> is a type used for returning and propagating errors. It is a class with the variants: <code><a class="el" href="structstx_1_1Ok.html">Ok</a>&lt;T&gt;</code>, representing success and containing a value, and <code><a class="el" href="structstx_1_1Err.html" title="error-value variant for Result&lt;T, E&gt; wrapping the contained error ">Err</a>&lt;E&gt;</code>, representing error and containing an error value.</p>
<p>Functions return <code><a class="el" href="classstx_1_1Result.html">Result</a></code> whenever errors are expected and recoverable.</p>
<p>A simple function returning <code><a class="el" href="classstx_1_1Result.html">Result</a></code> might be defined and used like so:</p>
<div class="fragment"><div class="line"><span class="keyword">enum class</span> Version { Version1 = 1, Version2 = 2 };</div><div class="line"></div><div class="line"><span class="keyword">auto</span> parse_version =</div><div class="line">     [](array&lt;uint8_t, 5&gt; <span class="keyword">const</span>&amp; header) -&gt; Result&lt;Version, string_view&gt; {</div><div class="line">   <span class="keywordflow">switch</span> (header.at(0)) {</div><div class="line">     <span class="keywordflow">case</span> 1:</div><div class="line">       <span class="keywordflow">return</span> Ok(Version::Version1);</div><div class="line">     <span class="keywordflow">case</span> 2:</div><div class="line">       <span class="keywordflow">return</span> Ok(Version::Version2);</div><div class="line">     <span class="keywordflow">default</span>:</div><div class="line">       <span class="keywordflow">return</span> Err(<span class="stringliteral">&quot;invalid version&quot;</span>sv);</div><div class="line">   }</div><div class="line"> };</div><div class="line"></div><div class="line">parse_version({1u, 2u, 3u, 4u, 5u})</div><div class="line">    .<a class="code" href="classstx_1_1Result.html#a71b44d71b194ffba79f5fadc2b2b85a5">match</a>(</div><div class="line">        [](<span class="keyword">auto</span> value) { fmt::print(<span class="stringliteral">&quot;Working with version: {}\n&quot;</span>, value);</div><div class="line">        },</div><div class="line">        [](<span class="keyword">auto</span> <a class="code" href="classstx_1_1Result.html#a4548a280df6c073e970fb7492e64b738">err</a>) { fmt::print(<span class="stringliteral">&quot;Error parsing header: {}\n&quot;</span>, <a class="code" href="classstx_1_1Result.html#a4548a280df6c073e970fb7492e64b738">err</a>); });</div></div><!-- fragment --><p><code><a class="el" href="classstx_1_1Result.html">Result</a></code> comes with some convenience methods that make working with it more succinct.</p>
<div class="fragment"><div class="line">Result&lt;int, int&gt; good_result = Ok(10);</div><div class="line">Result&lt;int, int&gt; bad_result = Err(10);</div><div class="line"></div><div class="line"><span class="comment">// The `is_ok` and `is_err` methods do what they say.</span></div><div class="line">ASSERT_TRUE(good_result.is_ok() &amp;&amp; !good_result.is_err());</div><div class="line">ASSERT_TRUE(bad_result.is_err() &amp;&amp; !bad_result.is_ok());</div></div><!-- fragment --><p><code><a class="el" href="classstx_1_1Result.html">Result</a></code> is a type that represents either success (<code><a class="el" href="structstx_1_1Ok.html">Ok</a></code>) or failure (<code><a class="el" href="structstx_1_1Err.html" title="error-value variant for Result&lt;T, E&gt; wrapping the contained error ">Err</a></code>).</p>
<p><a class="el" href="classstx_1_1Result.html">Result</a> is either in the <a class="el" href="structstx_1_1Ok.html">Ok</a> or <a class="el" href="structstx_1_1Err.html" title="error-value variant for Result&lt;T, E&gt; wrapping the contained error ">Err</a> state at any point in time </p>
</div><div class="dynheader">
Collaboration diagram for stx::Result&lt; T, E &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classstx_1_1Result__coll__graph.png" border="0" usemap="#stx_1_1Result_3_01T_00_01E_01_4_coll__map" alt="Collaboration graph"/></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a807d28724ecb7c88a1bc71f1f704d06d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a807d28724ecb7c88a1bc71f1f704d06d">&#9670;&nbsp;</a></span>error_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::<a class="el" href="classstx_1_1Result.html#a807d28724ecb7c88a1bc71f1f704d06d">error_type</a> =  E</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a70652ec2d0d23d66d0eb0ed79298171c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70652ec2d0d23d66d0eb0ed79298171c">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::<a class="el" href="classstx_1_1Result.html#a70652ec2d0d23d66d0eb0ed79298171c">value_type</a> =  T</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af95769194b41887e66a5e01cd9f2aba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af95769194b41887e66a5e01cd9f2aba6">&#9670;&nbsp;</a></span>Result() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::<a class="el" href="classstx_1_1Result.html">Result</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1Ok.html">Ok</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a831e2b258f37867f17e5a924017d3edc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a831e2b258f37867f17e5a924017d3edc">&#9670;&nbsp;</a></span>Result() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::<a class="el" href="classstx_1_1Result.html">Result</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1Err.html">Err</a>&lt; E &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>err</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0cb86dae29a262fbbbfd0bfec4c7d8fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cb86dae29a262fbbbfd0bfec4c7d8fa">&#9670;&nbsp;</a></span>Result() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::<a class="el" href="classstx_1_1Result.html">Result</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstx_1_1Result.html">Result</a>&lt; T, E &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae366d626a55c02884081ef01e34c0566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae366d626a55c02884081ef01e34c0566">&#9670;&nbsp;</a></span>Result() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::<a class="el" href="classstx_1_1Result.html">Result</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a66a498bb326209e5a0c711af6bf13cd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66a498bb326209e5a0c711af6bf13cd0">&#9670;&nbsp;</a></span>Result() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::<a class="el" href="classstx_1_1Result.html">Result</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstx_1_1Result.html">Result</a>&lt; T, E &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac37c96a17a61a516d25e73e7bb8e55d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac37c96a17a61a516d25e73e7bb8e55d9">&#9670;&nbsp;</a></span>~Result()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::~<a class="el" href="classstx_1_1Result.html">Result</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae1cae4945f3fd21dce53fc179e9ea4df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1cae4945f3fd21dce53fc179e9ea4df">&#9670;&nbsp;</a></span>AND()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<div class="memtemplate">
template&lt;typename U , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">requires <a class="el" href="namespacestx.html#aa0bd2b8f4938c62598f62d340bd74008">convertible_to</a>&lt;E, F&gt; [[nodiscard]] constexpr auto <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::AND </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstx_1_1Result.html">Result</a>&lt; U, F &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td> &amp;&amp; -&gt; <a class="el" href="classstx_1_1Result.html">Result</a>&lt;U, F&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <code>res</code> if the result is <code><a class="el" href="structstx_1_1Ok.html">Ok</a></code>, otherwise returns the <code><a class="el" href="structstx_1_1Err.html" title="error-value variant for Result&lt;T, E&gt; wrapping the contained error ">Err</a></code> value of itself.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line">Result&lt;int, string_view&gt; a = Ok(2);</div><div class="line">Result&lt;string_view, string_view&gt; b = Err(<span class="stringliteral">&quot;late error&quot;</span>sv);</div><div class="line">ASSERT_EQ(move(a).<a class="code" href="classstx_1_1Result.html#ae1cae4945f3fd21dce53fc179e9ea4df">AND</a>(move(b)), Err(<span class="stringliteral">&quot;late error&quot;</span>sv));</div><div class="line"></div><div class="line">Result&lt;int, string_view&gt; c = Err(<span class="stringliteral">&quot;early error&quot;</span>sv);</div><div class="line">Result&lt;string_view, string_view&gt; d = Ok(<span class="stringliteral">&quot;foo&quot;</span>sv);</div><div class="line">ASSERT_EQ(move(c).<a class="code" href="classstx_1_1Result.html#ae1cae4945f3fd21dce53fc179e9ea4df">AND</a>(move(d)), Err(<span class="stringliteral">&quot;early error&quot;</span>sv));</div><div class="line"></div><div class="line">Result&lt;int, string_view&gt; e = Err(<span class="stringliteral">&quot;not a 2&quot;</span>sv);</div><div class="line">Result&lt;string_view, string_view&gt; f = Err(<span class="stringliteral">&quot;late error&quot;</span>sv);</div><div class="line">ASSERT_EQ(move(e).<a class="code" href="classstx_1_1Result.html#ae1cae4945f3fd21dce53fc179e9ea4df">AND</a>(move(f)), Err(<span class="stringliteral">&quot;not a 2&quot;</span>sv));</div><div class="line"></div><div class="line">Result&lt;int, string_view&gt; g = Ok(2);</div><div class="line">Result&lt;string_view, string_view&gt; h = Ok(<span class="stringliteral">&quot;different result type&quot;</span>sv);</div><div class="line">ASSERT_EQ(move(g).<a class="code" href="classstx_1_1Result.html#ae1cae4945f3fd21dce53fc179e9ea4df">AND</a>(move(h)), Ok(<span class="stringliteral">&quot;different result type&quot;</span>sv));</div></div><!-- fragment --> 
</div>
</div>
<a id="ab1e21aa31758b2d48e9c9d4937868343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1e21aa31758b2d48e9c9d4937868343">&#9670;&nbsp;</a></span>and_then()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">requires <a class="el" href="namespacestx.html#aa8f14c3c14e6dcdecfdf0710ee2ed774">invocable</a>&lt;Fn&amp;&amp;, T&amp;&amp;&gt; [[nodiscard]] constexpr auto <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::and_then </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> &amp;&amp; -&gt; <a class="el" href="classstx_1_1Result.html">Result</a>&lt;<a class="el" href="namespacestx.html#ac43d924d52c43f451ac8f9a9ae00934b">invoke_result</a>&lt;Fn&amp;&amp;, T&amp;&amp;&gt;, E&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calls <code>op</code> if the result is <code><a class="el" href="structstx_1_1Ok.html">Ok</a></code>, otherwise returns the <code><a class="el" href="structstx_1_1Err.html" title="error-value variant for Result&lt;T, E&gt; wrapping the contained error ">Err</a></code> value of itself.</p>
<p>This function can be used for control flow based on <code><a class="el" href="classstx_1_1Result.html">Result</a></code> values.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> sq = [](<span class="keywordtype">int</span> x) { <span class="keywordflow">return</span> x * x; };</div><div class="line"></div><div class="line"><span class="keyword">auto</span> <a class="code" href="namespacestx.html#a1754a6b0876636dda571d46f50182507">make_ok</a> = [](<span class="keywordtype">int</span> x) -&gt; Result&lt;int, int&gt; { <span class="keywordflow">return</span> Ok(move(x)); };</div><div class="line"><span class="keyword">auto</span> <a class="code" href="namespacestx.html#aad98263198e88a079235f2845bd1ae09">make_err</a> = [](<span class="keywordtype">int</span> x) -&gt; Result&lt;int, int&gt; { <span class="keywordflow">return</span> Err(move(x)); };</div><div class="line"></div><div class="line">ASSERT_EQ(<a class="code" href="namespacestx.html#a1754a6b0876636dda571d46f50182507">make_ok</a>(2).<a class="code" href="classstx_1_1Result.html#ab1e21aa31758b2d48e9c9d4937868343">and_then</a>(sq).<a class="code" href="classstx_1_1Result.html#ab1e21aa31758b2d48e9c9d4937868343">and_then</a>(sq), Ok(16));</div><div class="line">ASSERT_EQ(<a class="code" href="namespacestx.html#aad98263198e88a079235f2845bd1ae09">make_err</a>(3).<a class="code" href="classstx_1_1Result.html#ab1e21aa31758b2d48e9c9d4937868343">and_then</a>(sq).<a class="code" href="classstx_1_1Result.html#ab1e21aa31758b2d48e9c9d4937868343">and_then</a>(sq), Err(3));</div></div><!-- fragment --> 
</div>
</div>
<a id="a6e32fcbf13feb357586a03f70ab0bbb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e32fcbf13feb357586a03f70ab0bbb9">&#9670;&nbsp;</a></span>as_const_deref() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::as_const_deref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs a constant dereference on <code>T</code>. if <code>T</code> is a pointer, C++-style iterator or smart-pointer. i.e. Converts <code><a class="el" href="classstx_1_1Result.html">Result</a>&lt;T, E&gt;</code> to <code><a class="el" href="classstx_1_1Result.html">Result</a>&lt;ConstRef&lt;U&gt;, ConstRef&lt;E&gt;&gt;</code> Where:</p><ul>
<li><code>U</code> represents the value obtained from dereferencing <code>T</code> and <code>ConstRef&lt;U&gt;</code> is a constant reference to a value pointed to by the value's pointer-type <code>T</code></li>
</ul>
<h1>NOTE</h1>
<p><code>ConstRef&lt;U&gt;</code> is an alias for <code>std::reference_wrapper&lt;U const&gt;</code>, but that's too long :) </p><h1>NOTE</h1>
<p>If <code>T</code> is an owning pointer/iterator/object, This result should live just as long as the dereference result obtained by calling this method.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> v = 98;</div><div class="line"></div><div class="line">Result&lt;int*, string_view&gt; x = Ok(&amp;v);</div><div class="line">ConstRef&lt;int&gt; v_ref = x.as_const_deref().unwrap();</div><div class="line"></div><div class="line">ASSERT_EQ(v_ref.get(), 98);    <span class="comment">// check the values</span></div><div class="line">ASSERT_EQ(&amp;v_ref.get(), &amp;v);  <span class="comment">// check their addresses</span></div><div class="line"></div><div class="line">Result&lt;int*, string_view&gt; y = Err(<span class="stringliteral">&quot;Errrr....&quot;</span>sv);</div><div class="line">ConstRef&lt;string_view&gt; y_err_ref = y.as_const_deref().unwrap_err();</div><div class="line">ASSERT_EQ(y_err_ref.get(), <span class="stringliteral">&quot;Errrr....&quot;</span>sv);  <span class="comment">// check the string-view&#39;s</span></div><div class="line">                                            <span class="comment">// value</span></div></div><!-- fragment --> 
</div>
</div>
<a id="ad8b264681661436515ee541484d8ed50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8b264681661436515ee541484d8ed50">&#9670;&nbsp;</a></span>as_const_deref() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::as_const_deref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9aa9afc1b2c17d1bf14635a64109569e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aa9afc1b2c17d1bf14635a64109569e">&#9670;&nbsp;</a></span>as_const_deref_err() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::as_const_deref_err </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs a constant dereference on <code>E</code>. if <code>E</code> is a pointer, C++-style iterator or smart-pointer. i.e. Converts <code><a class="el" href="classstx_1_1Result.html">Result</a>&lt;T, E&gt;</code> to <code><a class="el" href="classstx_1_1Result.html">Result</a>&lt;ConstRef&lt;T&gt;, ConstRef&lt;F&gt;&gt;</code> Where:</p><ul>
<li><code>F</code> represents the value obtained from dereferencing <code>E</code> and <code>ConstRef&lt;F&gt;</code> is a constant reference to a value pointed to by the error's pointer-type <code>E</code></li>
</ul>
<h1>NOTE</h1>
<p><code>ConstRef&lt;F&gt;</code> is an alias for <code>std::reference_wrapper&lt;F const&gt;</code>, but that's too long :)</p>
<h1>NOTE</h1>
<p>If <code>E</code> is an owning pointer/iterator/object, This result should live just as long as the dereference result obtained by calling this method.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line">Result&lt;int, string_view*&gt; x = Ok(2);</div><div class="line">ConstRef&lt;int&gt; x_value_ref = x.as_const_deref_err().unwrap();</div><div class="line">ASSERT_EQ(x_value_ref.get(), 2);  <span class="comment">// check their values</span></div><div class="line"></div><div class="line">string_view e = <span class="stringliteral">&quot;Errrr....&quot;</span>sv;</div><div class="line"></div><div class="line">Result&lt;int, string_view*&gt; y = Err(&amp;e);</div><div class="line">ConstRef&lt;string_view&gt; y_err_ref = y.as_const_deref_err().unwrap_err();</div><div class="line"></div><div class="line">ASSERT_EQ(y_err_ref.get(), e);    <span class="comment">// check their values</span></div><div class="line">ASSERT_EQ(&amp;y_err_ref.get(), &amp;e);  <span class="comment">// check their addresses</span></div></div><!-- fragment --> 
</div>
</div>
<a id="a756cad021381ca89e76a394e237b445e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a756cad021381ca89e76a394e237b445e">&#9670;&nbsp;</a></span>as_const_deref_err() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::as_const_deref_err </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4f0619b2998fe5592a0ed492a1b7cbb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f0619b2998fe5592a0ed492a1b7cbb1">&#9670;&nbsp;</a></span>as_cref() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::as_cref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp; -&gt; <a class="el" href="classstx_1_1Result.html">Result</a>&lt;<a class="el" href="namespacestx.html#a910046924ff264eb1eec0707011908ee">ConstRef</a>&lt;T&gt;, <a class="el" href="namespacestx.html#a910046924ff264eb1eec0707011908ee">ConstRef</a>&lt;E&gt;&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts from <code><a class="el" href="classstx_1_1Result.html">Result</a>&lt;T, E&gt; &amp;</code> to <code><a class="el" href="classstx_1_1Result.html">Result</a>&lt;ConstRef&lt;T&gt;, ConstRef&lt;E&gt;&gt;</code>.</p>
<p>Produces a new <code><a class="el" href="classstx_1_1Result.html">Result</a></code>, containing an immutable reference into the original, leaving the original in place.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line">Result&lt;int, string&gt; x = Ok(2);</div><div class="line">ASSERT_EQ(x.as_cref().unwrap().get(), 2);</div><div class="line"></div><div class="line">Result&lt;int, string&gt; y = Err(<span class="stringliteral">&quot;Error&quot;</span>s);</div><div class="line">ASSERT_EQ(y.as_cref().unwrap_err().get(), <span class="stringliteral">&quot;Error&quot;</span>s);</div></div><!-- fragment --> 
</div>
</div>
<a id="aef37786f17042833c3d9b6db58c34500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef37786f17042833c3d9b6db58c34500">&#9670;&nbsp;</a></span>as_cref() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::as_cref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;&amp; -&gt;  <a class="el" href="classstx_1_1Result.html">Result</a>&lt; <a class="el" href="namespacestx.html#a910046924ff264eb1eec0707011908ee">ConstRef</a>&lt; T &gt;, <a class="el" href="namespacestx.html#a910046924ff264eb1eec0707011908ee">ConstRef</a>&lt; E &gt;&gt;=delete</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a77cda858deaaf6e1eaa846d1aea04b17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77cda858deaaf6e1eaa846d1aea04b17">&#9670;&nbsp;</a></span>as_mut_deref() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::as_mut_deref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs a mutable dereference on <code>T</code>, if <code>T</code> is a pointer, C++-style iterator or smart-pointer. i.e. Converts <code><a class="el" href="classstx_1_1Result.html">Result</a>&lt;T, E&gt;</code> to <code><a class="el" href="classstx_1_1Result.html">Result</a>&lt;MutRef&lt;U&gt;, MutRef&lt;E&gt;&gt;</code> Where:</p><ul>
<li><code>U</code> represents the value obtained from dereferencing <code>T</code> and <code>MutRef&lt;U&gt;</code> is a mutable reference to a value pointed to by the value's pointer-type <code>T</code></li>
</ul>
<h1>NOTE</h1>
<p><code>MutRef&lt;U&gt;</code> is an alias for std::reference_wrapper&lt;U&gt;, but that's too long :) </p><h1>NOTE</h1>
<p>If <code>T</code> is an owning pointer/iterator/object, This result should live just as long as the dereference result obtained by calling this method.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> v = 98;</div><div class="line"></div><div class="line">Result&lt;int*, string_view&gt; x = Ok(&amp;v);</div><div class="line">MutRef&lt;int&gt; v_ref = x.as_mut_deref().unwrap();</div><div class="line"></div><div class="line">ASSERT_EQ(v_ref.get(), 98);   <span class="comment">// check the values</span></div><div class="line">ASSERT_EQ(&amp;v_ref.get(), &amp;v);  <span class="comment">// check their addresses</span></div><div class="line"></div><div class="line">v_ref.get() = -404;  <span class="comment">// change v&#39;s value via the mutable reference</span></div><div class="line"></div><div class="line">ASSERT_EQ(v_ref.get(), -404);  <span class="comment">// check that the reference&#39;s value changed</span></div><div class="line">ASSERT_EQ(v, -404);            <span class="comment">// check that v&#39;s value changed</span></div><div class="line">ASSERT_EQ(v_ref.get(), v);     <span class="comment">// check that both v and v_ref are equal</span></div><div class="line">ASSERT_EQ(&amp;v_ref.get(), &amp;v);   <span class="comment">// check that v_ref references v</span></div><div class="line"></div><div class="line">Result&lt;int*, string_view&gt; y = Err(<span class="stringliteral">&quot;Errrr....&quot;</span>sv);</div><div class="line">MutRef&lt;string_view&gt; y_err_ref = y.as_mut_deref().unwrap_err();</div><div class="line">ASSERT_EQ(y_err_ref.get(), <span class="stringliteral">&quot;Errrr....&quot;</span>sv);</div><div class="line"></div><div class="line">y_err_ref.get() = <span class="stringliteral">&quot;Omoshiroi!...&quot;</span>sv;  <span class="comment">// change the error&#39;s value</span></div><div class="line"></div><div class="line">ASSERT_EQ(y, Err(<span class="stringliteral">&quot;Omoshiroi!...&quot;</span>sv));  <span class="comment">// check that the error&#39;s value was</span></div><div class="line">                                       <span class="comment">// actually changed</span></div></div><!-- fragment --> 
</div>
</div>
<a id="ae504d870399d600c77afae592c6060f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae504d870399d600c77afae592c6060f8">&#9670;&nbsp;</a></span>as_mut_deref() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::as_mut_deref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1b288584ede22ecde5f90d9f6dbca7f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b288584ede22ecde5f90d9f6dbca7f9">&#9670;&nbsp;</a></span>as_mut_deref_err() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::as_mut_deref_err </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs a mutable dereference on <code>E</code>, if <code>E</code> is a pointer, C++-style iterator or smart-pointer. i.e. Converts <code><a class="el" href="classstx_1_1Result.html">Result</a>&lt;T, E&gt;</code> to <code><a class="el" href="classstx_1_1Result.html">Result</a>&lt;MutRef&lt;T&gt;, MutRef&lt;F&gt;&gt;</code> Where:</p><ul>
<li><code>F</code> represents the value obtained from dereferencing <code>E</code> and <code>MutRef&lt;F&gt;</code> is a mutable reference to a value pointed to by the value's pointer-type <code>T</code></li>
</ul>
<h1>NOTE</h1>
<p><code>MutRef&lt;F&gt;</code> is an alias for std::reference_wrapper&lt;F&gt;, but that's too long :)</p>
<h1>NOTE</h1>
<p>If <code>E</code> is an owning pointer/iterator/object, This result should live just as long as the dereference result obtained by calling this method.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> e = 98;</div><div class="line"></div><div class="line">Result&lt;string_view, int*&gt; x = Err(&amp;e);</div><div class="line">MutRef&lt;int&gt; e_ref = x.as_mut_deref_err().unwrap_err();</div><div class="line"></div><div class="line">ASSERT_EQ(e_ref.get(), 98);   <span class="comment">// check the values</span></div><div class="line">ASSERT_EQ(&amp;e_ref.get(), &amp;e);  <span class="comment">// check their addresses</span></div><div class="line"></div><div class="line">e_ref.get() = -404;  <span class="comment">// change e&#39;s value via the mutable reference</span></div><div class="line"></div><div class="line">ASSERT_EQ(e_ref.get(), -404);  <span class="comment">// check that the reference&#39;s value changed</span></div><div class="line">ASSERT_EQ(e, -404);            <span class="comment">// check that v&#39;s value changed</span></div><div class="line">ASSERT_EQ(e_ref.get(), e);     <span class="comment">// check that both v and v_ref are equal</span></div><div class="line">ASSERT_EQ(&amp;e_ref.get(), &amp;e);   <span class="comment">// check that v_ref references v</span></div><div class="line"></div><div class="line">Result&lt;string_view, int*&gt; y = Ok(<span class="stringliteral">&quot;Errrr....&quot;</span>sv);</div><div class="line">MutRef&lt;string_view&gt; y_err_ref = y.as_mut_deref_err().unwrap();</div><div class="line">ASSERT_EQ(y_err_ref.get(), <span class="stringliteral">&quot;Errrr....&quot;</span>sv);</div><div class="line"></div><div class="line">y_err_ref.get() = <span class="stringliteral">&quot;Omoshiroi!...&quot;</span>sv;  <span class="comment">// change the error&#39;s value</span></div><div class="line"></div><div class="line">ASSERT_EQ(y, Ok(<span class="stringliteral">&quot;Omoshiroi!...&quot;</span>sv));  <span class="comment">// check that the error&#39;s value was</span></div><div class="line">                                      <span class="comment">// actually changed</span></div></div><!-- fragment --> 
</div>
</div>
<a id="ab3bc5d3a9e7d8b271e7369eb614d09d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3bc5d3a9e7d8b271e7369eb614d09d1">&#9670;&nbsp;</a></span>as_mut_deref_err() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::as_mut_deref_err </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b1925b08cd1ec54f6096c343d8ead51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b1925b08cd1ec54f6096c343d8ead51">&#9670;&nbsp;</a></span>as_ref() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::as_ref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp; -&gt; <a class="el" href="classstx_1_1Result.html">Result</a>&lt;<a class="el" href="namespacestx.html#a1b55420e0cd6b42317f23d32831d1637">MutRef</a>&lt;T&gt;, <a class="el" href="namespacestx.html#a1b55420e0cd6b42317f23d32831d1637">MutRef</a>&lt;E&gt;&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts from <code><a class="el" href="classstx_1_1Result.html">Result</a>&lt;T, E&gt; &amp;</code> to <code><a class="el" href="classstx_1_1Result.html">Result</a>&lt;MutRef&lt;T&gt;, MutRef&lt;E&gt;&gt;</code>.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> mutate = [](Result&lt;int, int&gt;&amp; r) {</div><div class="line"> r.as_ref().match([](<span class="keyword">auto</span> <a class="code" href="classstx_1_1Result.html#a647e469eda74b8d34a67bab67176b093">ok</a>) { <a class="code" href="classstx_1_1Result.html#a647e469eda74b8d34a67bab67176b093">ok</a>.get() = 42; },</div><div class="line">                      [](<span class="keyword">auto</span> <a class="code" href="classstx_1_1Result.html#a4548a280df6c073e970fb7492e64b738">err</a>) { <a class="code" href="classstx_1_1Result.html#a4548a280df6c073e970fb7492e64b738">err</a>.get() = 0; });</div><div class="line">};</div><div class="line"></div><div class="line">Result&lt;int, int&gt; x = Ok(2);</div><div class="line">mutate(x);</div><div class="line">ASSERT_EQ(x, Ok(42));</div><div class="line"></div><div class="line">Result&lt;int, int&gt; y = Err(13);</div><div class="line">mutate(y);</div><div class="line">ASSERT_EQ(y, Err(0));</div></div><!-- fragment --> 
</div>
</div>
<a id="acc1cb8410d380de1d614efd23adc2191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc1cb8410d380de1d614efd23adc2191">&#9670;&nbsp;</a></span>as_ref() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::as_ref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp; -&gt;  <a class="el" href="classstx_1_1Result.html">Result</a>&lt; <a class="el" href="namespacestx.html#a1b55420e0cd6b42317f23d32831d1637">MutRef</a>&lt; T &gt;, <a class="el" href="namespacestx.html#a1b55420e0cd6b42317f23d32831d1637">MutRef</a>&lt; E &gt;&gt;=delete</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0006cd708c72b1bcb11ff2358c2346ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0006cd708c72b1bcb11ff2358c2346ce">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classstx_1_1Result.html">Result</a>&lt;T, E&gt; requires <a class="el" href="namespacestx.html#ac27784f661f2d1e57b357110b69ec260">copy_constructible</a>&lt;T&gt;&amp;&amp; <a class="el" href="namespacestx.html#ac27784f661f2d1e57b357110b69ec260">copy_constructible</a>&lt;E&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac533672498aebfa871eaaa02e7b1c382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac533672498aebfa871eaaa02e7b1c382">&#9670;&nbsp;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<div class="memtemplate">
template&lt;typename CmpType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">requires <a class="el" href="namespacestx.html#a81068b2d8a2b022352d7695cf90d733b">equality_comparable</a>&lt;T const&amp;, CmpType const&amp;&gt; [[nodiscard]] constexpr bool <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">CmpType const &amp;&#160;</td>
          <td class="paramname"><em>cmp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <code>true</code> if the result is an <code><a class="el" href="structstx_1_1Ok.html">Ok</a>&lt;T&gt;</code> variant and contains the given value.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line">Result&lt;int, string&gt; x = Ok(2);</div><div class="line">ASSERT_TRUE(x.contains(2));</div><div class="line"></div><div class="line">Result&lt;int, string&gt; y = Ok(3);</div><div class="line">ASSERT_FALSE(y.contains(2));</div><div class="line"></div><div class="line">Result&lt;int, string&gt; z = Err(<span class="stringliteral">&quot;Some error message&quot;</span>s);</div><div class="line">ASSERT_FALSE(z.contains(2));</div></div><!-- fragment --> 
</div>
</div>
<a id="ac5f8f745c2a756b3f16ed5ce548c8d50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5f8f745c2a756b3f16ed5ce548c8d50">&#9670;&nbsp;</a></span>contains_err()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<div class="memtemplate">
template&lt;typename ErrCmp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">requires <a class="el" href="namespacestx.html#a81068b2d8a2b022352d7695cf90d733b">equality_comparable</a>&lt;E const&amp;, ErrCmp const&amp;&gt; [[nodiscard]] constexpr bool <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::contains_err </td>
          <td>(</td>
          <td class="paramtype">ErrCmp const &amp;&#160;</td>
          <td class="paramname"><em>cmp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <code>true</code> if the result is an <code><a class="el" href="structstx_1_1Err.html" title="error-value variant for Result&lt;T, E&gt; wrapping the contained error ">Err</a>&lt;E&gt;</code> variant containing the given value.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line">Result&lt;int, string&gt; x = Ok(2);</div><div class="line">ASSERT_FALSE(x.contains_err(<span class="stringliteral">&quot;Some error message&quot;</span>s));</div><div class="line"></div><div class="line">Result&lt;int, string&gt; y = Err(<span class="stringliteral">&quot;Some error message&quot;</span>s);</div><div class="line">ASSERT_TRUE(y.contains_err(<span class="stringliteral">&quot;Some error message&quot;</span>s));</div><div class="line"></div><div class="line">Result&lt;int, string&gt; z = Err(<span class="stringliteral">&quot;Some other error message&quot;</span>s);</div><div class="line">ASSERT_FALSE(z.contains_err(<span class="stringliteral">&quot;Some error message&quot;</span>s));</div></div><!-- fragment --> 
</div>
</div>
<a id="a4548a280df6c073e970fb7492e64b738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4548a280df6c073e970fb7492e64b738">&#9670;&nbsp;</a></span>err()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::err </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp; -&gt; <a class="el" href="classstx_1_1Option.html">Option</a>&lt;E&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts from <code><a class="el" href="classstx_1_1Result.html">Result</a>&lt;T, E&gt;</code> to <code><a class="el" href="classstx_1_1Option.html">Option</a>&lt;E&gt;</code>.</p>
<p>Converts this result into an <code><a class="el" href="classstx_1_1Option.html">Option</a>&lt;E&gt;</code>, consuming itself, and discarding the success value, if any.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line">Result&lt;int, string&gt; x = Ok(2);</div><div class="line">ASSERT_EQ(move(x).<a class="code" href="classstx_1_1Result.html#a4548a280df6c073e970fb7492e64b738">err</a>(), <a class="code" href="namespacestx.html#a9ba8a760ec020ea9b105ae6060494203">None</a>);</div><div class="line"></div><div class="line">Result&lt;int, string&gt; y = Err(<span class="stringliteral">&quot;Nothing here&quot;</span>s);</div><div class="line">ASSERT_EQ(move(y).<a class="code" href="classstx_1_1Result.html#a4548a280df6c073e970fb7492e64b738">err</a>(), Some(<span class="stringliteral">&quot;Nothing here&quot;</span>s));</div></div><!-- fragment --> 
</div>
</div>
<a id="aa85e4cd43d8f9e21cb3970f19954f7cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa85e4cd43d8f9e21cb3970f19954f7cb">&#9670;&nbsp;</a></span>err_exists()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<div class="memtemplate">
template&lt;typename UnaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">requires <a class="el" href="namespacestx.html#aa8f14c3c14e6dcdecfdf0710ee2ed774">invocable</a>&lt;UnaryPredicate&amp;&amp;, E const&amp;&gt;&amp;&amp; <a class="el" href="namespacestx.html#aa0bd2b8f4938c62598f62d340bd74008">convertible_to</a>&lt;<a class="el" href="namespacestx.html#ac43d924d52c43f451ac8f9a9ae00934b">invoke_result</a>&lt;UnaryPredicate&amp;&amp;, E const&amp;&gt;, bool&gt; [[nodiscard]] constexpr bool <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::err_exists </td>
          <td>(</td>
          <td class="paramtype">UnaryPredicate &amp;&amp;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the value of evaluating the <code>predicate</code> on the contained value if the <code><a class="el" href="classstx_1_1Option.html">Option</a></code> is a <code><a class="el" href="structstx_1_1Some.html">Some</a></code>, else returns <code>false</code>.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line">Result&lt;int, string&gt; x = Err(<span class="stringliteral">&quot;invalid&quot;</span>s);</div><div class="line"><span class="keyword">auto</span> invalid = [](<span class="keyword">auto</span> x) { <span class="keywordflow">return</span> x == <span class="stringliteral">&quot;invalid&quot;</span>; };</div><div class="line"></div><div class="line">ASSERT_TRUE(x.err_exists(invalid));</div></div><!-- fragment --> 
</div>
</div>
<a id="a05656bba7ff00549e0e9aa054e50ad74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05656bba7ff00549e0e9aa054e50ad74">&#9670;&nbsp;</a></span>err_value() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">E&amp; <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::err_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an l-value reference to the contained error value. Note that no copying occurs here.</p>
<h1>Panics</h1>
<p>Panics if the value is an <code><a class="el" href="structstx_1_1Ok.html">Ok</a></code></p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> result = make_err&lt;int, int&gt;(9);</div><div class="line"><span class="keywordtype">int</span>&amp; <a class="code" href="classstx_1_1Result.html#a4548a280df6c073e970fb7492e64b738">err</a> = result.err_value();</div><div class="line">err = 46;</div><div class="line"></div><div class="line">ASSERT_EQ(result, Err(46));</div></div><!-- fragment --> 
</div>
</div>
<a id="ac951aa045c18bdb6396478b7b6679e33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac951aa045c18bdb6396478b7b6679e33">&#9670;&nbsp;</a></span>err_value() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">E const&amp; <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::err_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a const l-value reference to the contained error value. Note that no copying occurs here.</p>
<h1>Panics</h1>
<p>Panics if the value is an <code><a class="el" href="structstx_1_1Ok.html">Ok</a></code></p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> <span class="keyword">const</span> result = make_err&lt;int, int&gt;(9);</div><div class="line"><span class="keywordtype">int</span> <span class="keyword">const</span>&amp; err = result.err_value();</div><div class="line"></div><div class="line">ASSERT_EQ(err, 9);</div></div><!-- fragment --> 
</div>
</div>
<a id="a26ce4b1495efaf6e3b5eba80873d78f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26ce4b1495efaf6e3b5eba80873d78f7">&#9670;&nbsp;</a></span>err_value() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">E <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::err_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use <code><a class="el" href="classstx_1_1Result.html#afe3376a66e7cf9cb15728ba5f4605753">unwrap_err()</a></code> instead. </p>

</div>
</div>
<a id="a1766f844fd7cd69f851dcdf2024aac6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1766f844fd7cd69f851dcdf2024aac6e">&#9670;&nbsp;</a></span>err_value() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">E const <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::err_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use <code><a class="el" href="classstx_1_1Result.html#afe3376a66e7cf9cb15728ba5f4605753">unwrap_err()</a></code> instead. </p>

</div>
</div>
<a id="af3898e020be4aed891e5e90f350b5dde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3898e020be4aed891e5e90f350b5dde">&#9670;&nbsp;</a></span>exists()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<div class="memtemplate">
template&lt;typename UnaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">requires <a class="el" href="namespacestx.html#aa8f14c3c14e6dcdecfdf0710ee2ed774">invocable</a>&lt;UnaryPredicate&amp;&amp;, T const&amp;&gt;&amp;&amp; <a class="el" href="namespacestx.html#aa0bd2b8f4938c62598f62d340bd74008">convertible_to</a>&lt;<a class="el" href="namespacestx.html#ac43d924d52c43f451ac8f9a9ae00934b">invoke_result</a>&lt;UnaryPredicate&amp;&amp;, T const&amp;&gt;, bool&gt; [[nodiscard]] constexpr bool <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::exists </td>
          <td>(</td>
          <td class="paramtype">UnaryPredicate &amp;&amp;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the value of evaluating the <code>predicate</code> on the contained value if the <code><a class="el" href="classstx_1_1Option.html">Option</a></code> is a <code><a class="el" href="structstx_1_1Some.html">Some</a></code>, else returns <code>false</code>.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line">Result&lt;int, string&gt; x = Ok(2);</div><div class="line"><span class="keyword">auto</span> even = [](<span class="keyword">auto</span> x) { <span class="keywordflow">return</span> x == 2; };</div><div class="line"></div><div class="line">ASSERT_TRUE(x.exists(even));</div></div><!-- fragment --> 
</div>
</div>
<a id="a87ace0350f90e707006b76044f9fa9f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87ace0350f90e707006b76044f9fa9f8">&#9670;&nbsp;</a></span>expect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::expect </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td> &amp;&amp; -&gt; T </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unwraps a result, yielding the content of an <code><a class="el" href="structstx_1_1Ok.html">Ok</a></code>.</p>
<h1>Panics</h1>
<p>Panics if the value is an <code><a class="el" href="structstx_1_1Err.html" title="error-value variant for Result&lt;T, E&gt; wrapping the contained error ">Err</a></code>, with a panic message including the passed message, and the content of the <code><a class="el" href="structstx_1_1Err.html" title="error-value variant for Result&lt;T, E&gt; wrapping the contained error ">Err</a></code>.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line">Result&lt;int, string_view&gt; x = Err(<span class="stringliteral">&quot;emergency failure&quot;</span>sv);</div><div class="line">ASSERT_ANY_THROW(move(x).<a class="code" href="classstx_1_1Result.html#a87ace0350f90e707006b76044f9fa9f8">expect</a>(<span class="stringliteral">&quot;Testing expect&quot;</span>));</div></div><!-- fragment --> 
</div>
</div>
<a id="a1eb60223b23d0276df7e2e0b56a81005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eb60223b23d0276df7e2e0b56a81005">&#9670;&nbsp;</a></span>expect_err()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::expect_err </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td> &amp;&amp; -&gt; E </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unwraps a result, yielding the content of an <code><a class="el" href="structstx_1_1Err.html" title="error-value variant for Result&lt;T, E&gt; wrapping the contained error ">Err</a></code>.</p>
<h1>Panics</h1>
<p>Panics if the value is an <code><a class="el" href="structstx_1_1Ok.html">Ok</a></code>, with a panic message including the passed message, and the content of the <code><a class="el" href="structstx_1_1Ok.html">Ok</a></code>.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line">Result&lt;int, string_view&gt; x = Ok(10);</div><div class="line">ASSERT_ANY_THROW(move(x).<a class="code" href="classstx_1_1Result.html#a1eb60223b23d0276df7e2e0b56a81005">expect_err</a>(<span class="stringliteral">&quot;Testing expect_err&quot;</span>)); <span class="comment">// panics with</span></div><div class="line">                                                            <span class="comment">// &quot;Testing</span></div><div class="line">                                                            <span class="comment">// expect_err:</span></div><div class="line">                                                            <span class="comment">// 10&quot;</span></div></div><!-- fragment --> 
</div>
</div>
<a id="aa4e5bc1117850786e73e489340443a7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4e5bc1117850786e73e489340443a7c">&#9670;&nbsp;</a></span>is_err()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::is_err </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <code>true</code> if the result is <code><a class="el" href="structstx_1_1Err.html" title="error-value variant for Result&lt;T, E&gt; wrapping the contained error ">Err</a>&lt;T&gt;</code>.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line">Result&lt;int, string_view&gt; x = Ok(-3);</div><div class="line">ASSERT_FALSE(x.is_err());</div><div class="line"></div><div class="line">Result&lt;int, string_view&gt; y = Err(<span class="stringliteral">&quot;Some error message&quot;</span>sv);</div><div class="line">ASSERT_TRUE(y.is_err());</div></div><!-- fragment --> 
</div>
</div>
<a id="aed6b8a1eb140d1109fb47f2f9176e472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed6b8a1eb140d1109fb47f2f9176e472">&#9670;&nbsp;</a></span>is_ok()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::is_ok </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <code>true</code> if the result is an <code><a class="el" href="structstx_1_1Ok.html">Ok</a>&lt;T&gt;</code> variant.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line">Result&lt;int, string_view&gt; x = Ok(-3);</div><div class="line">ASSERT_TRUE(x.is_ok());</div><div class="line"></div><div class="line">Result&lt;int, string_view&gt; y = Err(<span class="stringliteral">&quot;Some error message&quot;</span>sv);</div><div class="line">ASSERT_FALSE(y.is_ok());</div></div><!-- fragment --> 
</div>
</div>
<a id="abfc185e50e411fd599f7c3b1352a6cd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfc185e50e411fd599f7c3b1352a6cd6">&#9670;&nbsp;</a></span>map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">requires <a class="el" href="namespacestx.html#aa8f14c3c14e6dcdecfdf0710ee2ed774">invocable</a>&lt;Fn&amp;&amp;, T&amp;&amp;&gt; [[nodiscard]] constexpr auto <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::map </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> &amp;&amp; -&gt; <a class="el" href="classstx_1_1Result.html">Result</a>&lt;<a class="el" href="namespacestx.html#ac43d924d52c43f451ac8f9a9ae00934b">invoke_result</a>&lt;Fn&amp;&amp;, T&amp;&amp;&gt;, E&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Maps a <code><a class="el" href="classstx_1_1Result.html">Result</a>&lt;T, E&gt;</code> to <code><a class="el" href="classstx_1_1Result.html">Result</a>&lt;U, E&gt;</code> by applying the function <code>op</code> to the contained <code><a class="el" href="structstx_1_1Ok.html">Ok</a>&lt;T&gt;</code> value, leaving an <code><a class="el" href="structstx_1_1Err.html" title="error-value variant for Result&lt;T, E&gt; wrapping the contained error ">Err</a>&lt;E&gt;</code> value untouched.</p>
<p>This function can be used to compose the results of two functions.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<p>Extract the content-type from an http header</p>
<div class="fragment"><div class="line"><span class="keyword">enum class</span> Error { InvalidHeader };</div><div class="line"><span class="keyword">auto</span> header = <span class="stringliteral">&quot;Content-Type: multipart/form-data&quot;</span>sv;</div><div class="line"></div><div class="line"><span class="keyword">auto</span> check_header = [](string_view s) -&gt; Result&lt;string_view, Error&gt; {</div><div class="line"> <span class="keywordflow">if</span> (!s.starts_with(<span class="stringliteral">&quot;Content-Type: &quot;</span>sv)) <span class="keywordflow">return</span> Err(Error::InvalidHeader);</div><div class="line"> <span class="keywordflow">return</span> Ok(move(s));</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">auto</span> content_type =</div><div class="line">check_header(header).map([](<span class="keyword">auto</span> s) { <span class="keywordflow">return</span> s.substr(14); });</div><div class="line"></div><div class="line">ASSERT_EQ(content_type, Ok(<span class="stringliteral">&quot;multipart/form-data&quot;</span>sv));</div></div><!-- fragment --> 
</div>
</div>
<a id="a21e7127b5da4ac13b210075e798625f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21e7127b5da4ac13b210075e798625f0">&#9670;&nbsp;</a></span>map_err()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">requires <a class="el" href="namespacestx.html#aa8f14c3c14e6dcdecfdf0710ee2ed774">invocable</a>&lt;Fn&amp;&amp;, E&amp;&amp;&gt; [[nodiscard]] constexpr auto <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::map_err </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> &amp;&amp; -&gt; <a class="el" href="classstx_1_1Result.html">Result</a>&lt;T, <a class="el" href="namespacestx.html#ac43d924d52c43f451ac8f9a9ae00934b">invoke_result</a>&lt;Fn&amp;&amp;, E&amp;&amp;&gt;&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Maps a <code><a class="el" href="classstx_1_1Result.html">Result</a>&lt;T, E&gt;</code> to <code><a class="el" href="classstx_1_1Result.html">Result</a>&lt;T, F&gt;</code> by applying a function to a contained <code><a class="el" href="structstx_1_1Err.html" title="error-value variant for Result&lt;T, E&gt; wrapping the contained error ">Err</a></code> value, leaving an <code><a class="el" href="structstx_1_1Ok.html">Ok</a></code> value untouched.</p>
<p>This function can be used to pass through a successful result while handling an error.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> stringify = [](<span class="keyword">auto</span> x) { <span class="keywordflow">return</span> <span class="stringliteral">&quot;error code: &quot;</span> + std::to_string(x);</div><div class="line">};</div><div class="line"></div><div class="line">Result&lt;int, int&gt; x = Ok(2);</div><div class="line">ASSERT_EQ(move(x).<a class="code" href="classstx_1_1Result.html#a21e7127b5da4ac13b210075e798625f0">map_err</a>(stringify), Ok(2));</div><div class="line"></div><div class="line">Result&lt;int, int&gt; y = Err(404);</div><div class="line">ASSERT_EQ(move(y).<a class="code" href="classstx_1_1Result.html#a21e7127b5da4ac13b210075e798625f0">map_err</a>(stringify), Err(<span class="stringliteral">&quot;error code: 404&quot;</span>s));</div></div><!-- fragment --> 
</div>
</div>
<a id="a467b181d6fe3f490e5905a0f3cf83c3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a467b181d6fe3f490e5905a0f3cf83c3f">&#9670;&nbsp;</a></span>map_or()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<div class="memtemplate">
template&lt;typename Fn , typename AltType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">requires <a class="el" href="namespacestx.html#aa8f14c3c14e6dcdecfdf0710ee2ed774">invocable</a>&lt;Fn&amp;&amp;, T&amp;&amp;&gt; [[nodiscard]] constexpr auto <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::map_or </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AltType &amp;&amp;&#160;</td>
          <td class="paramname"><em>alt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> &amp;&amp; -&gt; <a class="el" href="namespacestx.html#ac43d924d52c43f451ac8f9a9ae00934b">invoke_result</a>&lt;Fn&amp;&amp;, T&amp;&amp;&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies a function to the contained value (if any), or returns the provided default (if not).</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line">Result&lt;string, int&gt; x = Ok(<span class="stringliteral">&quot;foo&quot;</span>s);</div><div class="line"><span class="keyword">auto</span> map_fn = [](<span class="keyword">auto</span> s) { <span class="keywordflow">return</span> s.size(); };</div><div class="line">ASSERT_EQ(move(x).<a class="code" href="classstx_1_1Result.html#a467b181d6fe3f490e5905a0f3cf83c3f">map_or</a>(map_fn, 42UL), 3UL);</div><div class="line"></div><div class="line">Result&lt;string, int&gt; y = Err(-404);</div><div class="line">ASSERT_EQ(move(y).<a class="code" href="classstx_1_1Result.html#a467b181d6fe3f490e5905a0f3cf83c3f">map_or</a>(map_fn, 42UL), 42UL);</div></div><!-- fragment --> 
</div>
</div>
<a id="a707189406ffb4fe12779d0c760504f3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a707189406ffb4fe12779d0c760504f3f">&#9670;&nbsp;</a></span>map_or_else()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<div class="memtemplate">
template&lt;typename Fn , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">requires <a class="el" href="namespacestx.html#aa8f14c3c14e6dcdecfdf0710ee2ed774">invocable</a>&lt;Fn&amp;&amp;, T&amp;&amp;&gt;&amp;&amp; <a class="el" href="namespacestx.html#aa8f14c3c14e6dcdecfdf0710ee2ed774">invocable</a>&lt;A&amp;&amp;, E&amp;&amp;&gt; [[nodiscard]] constexpr auto <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::map_or_else </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>alt_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> &amp;&amp; -&gt; <a class="el" href="namespacestx.html#ac43d924d52c43f451ac8f9a9ae00934b">invoke_result</a>&lt;Fn&amp;&amp;, T&amp;&amp;&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Maps a <code><a class="el" href="classstx_1_1Result.html">Result</a>&lt;T, E&gt;</code> to <code>U</code> by applying a function to a contained <code><a class="el" href="structstx_1_1Ok.html">Ok</a></code> value, or a fallback function to a contained <code><a class="el" href="structstx_1_1Err.html" title="error-value variant for Result&lt;T, E&gt; wrapping the contained error ">Err</a></code> value.</p>
<p>This function can be used to unpack a successful result while handling an error.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><span class="keywordtype">size_t</span> <span class="keyword">const</span> k = 21;</div><div class="line"></div><div class="line">Result&lt;string_view, size_t&gt; x = Ok(<span class="stringliteral">&quot;foo&quot;</span>sv);</div><div class="line"><span class="keyword">auto</span> map_fn = [](<span class="keyword">auto</span> s) { <span class="keywordflow">return</span> s.size(); };</div><div class="line"><span class="keyword">auto</span> else_fn = [&amp;](<span class="keyword">auto</span>) { <span class="keywordflow">return</span> k * 2UL; };</div><div class="line"></div><div class="line">ASSERT_EQ(move(x).<a class="code" href="classstx_1_1Result.html#a707189406ffb4fe12779d0c760504f3f">map_or_else</a>(map_fn, else_fn), 3);</div><div class="line"></div><div class="line">Result&lt;string_view, size_t&gt; y = Err(404UL);</div><div class="line">ASSERT_EQ(move(y).<a class="code" href="classstx_1_1Result.html#a707189406ffb4fe12779d0c760504f3f">map_or_else</a>(map_fn, else_fn), 42);</div></div><!-- fragment --> 
</div>
</div>
<a id="a71b44d71b194ffba79f5fadc2b2b85a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71b44d71b194ffba79f5fadc2b2b85a5">&#9670;&nbsp;</a></span>match()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<div class="memtemplate">
template&lt;typename OkFn , typename ErrFn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">requires <a class="el" href="namespacestx.html#aa8f14c3c14e6dcdecfdf0710ee2ed774">invocable</a>&lt;OkFn&amp;&amp;, T&amp;&amp;&gt;&amp;&amp; <a class="el" href="namespacestx.html#aa8f14c3c14e6dcdecfdf0710ee2ed774">invocable</a>&lt;ErrFn&amp;&amp;, E&amp;&amp;&gt; [[nodiscard]] constexpr auto <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::match </td>
          <td>(</td>
          <td class="paramtype">OkFn &amp;&amp;&#160;</td>
          <td class="paramname"><em>ok_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ErrFn &amp;&amp;&#160;</td>
          <td class="paramname"><em>err_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> &amp;&amp; -&gt; <a class="el" href="namespacestx.html#ac43d924d52c43f451ac8f9a9ae00934b">invoke_result</a>&lt;OkFn&amp;&amp;, T&amp;&amp;&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calls the parameter <code>ok_fn</code> with the value if this result is an <code><a class="el" href="structstx_1_1Ok.html">Ok</a>&lt;T&gt;</code>, else calls <code>err_fn</code> with the error. This result is consumed afterward.</p>
<p>The return type of both parameters must be same (without expecting implicit conversions). They can also both return nothing <code>void</code>.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> i = make_ok&lt;int, string_view&gt;(99);</div><div class="line"></div><div class="line"><span class="keyword">auto</span> j = move(i).match([](<span class="keywordtype">int</span> value) { <span class="keywordflow">return</span> <a class="code" href="classstx_1_1Result.html#a00c0c5eaa92721eb93ac36733bc8efc9">value</a>; },</div><div class="line">                       [](string_view) { <span class="keywordflow">return</span> -1; });</div><div class="line">ASSERT_EQ(j, 99);</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">auto</span> x = make_err&lt;int, string_view&gt;(<span class="stringliteral">&quot;404 Not Found&quot;</span>sv);</div><div class="line"><span class="comment">// you can return nothing</span></div><div class="line">move(x).match([](<span class="keywordtype">int</span>) {  },</div><div class="line">              [](string_view s) { fmt::print(<span class="stringliteral">&quot;Error: {}\n&quot;</span>, s); });</div></div><!-- fragment --> 
</div>
</div>
<a id="a647e469eda74b8d34a67bab67176b093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a647e469eda74b8d34a67bab67176b093">&#9670;&nbsp;</a></span>ok()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::ok </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp; -&gt; <a class="el" href="classstx_1_1Option.html">Option</a>&lt;T&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts from <code><a class="el" href="classstx_1_1Result.html">Result</a>&lt;T, E&gt;</code> to <code><a class="el" href="classstx_1_1Option.html">Option</a>&lt;T&gt;</code>.</p>
<p>Converts this result into an <code><a class="el" href="classstx_1_1Option.html">Option</a>&lt;T&gt;</code>, consuming itself, and discarding the error, if any.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line">Result&lt;int, string&gt; x = Ok(2);</div><div class="line">ASSERT_EQ(move(x).<a class="code" href="classstx_1_1Result.html#a647e469eda74b8d34a67bab67176b093">ok</a>(), Some(2));</div><div class="line"></div><div class="line">Result&lt;int, string&gt; y = Err(<span class="stringliteral">&quot;Nothing here&quot;</span>s);</div><div class="line">ASSERT_EQ(move(y).<a class="code" href="classstx_1_1Result.html#a647e469eda74b8d34a67bab67176b093">ok</a>(), <a class="code" href="namespacestx.html#a9ba8a760ec020ea9b105ae6060494203">None</a>);</div></div><!-- fragment --> 
</div>
</div>
<a id="abf7163cffd3c4ab4b12ebdf8d3e43524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf7163cffd3c4ab4b12ebdf8d3e43524">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstx_1_1Result.html">Result</a>&amp; <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstx_1_1Result.html">Result</a>&lt; T, E &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="accce70e349246b1a291b34d4a4ba80e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accce70e349246b1a291b34d4a4ba80e1">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstx_1_1Result.html">Result</a>&amp; <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstx_1_1Result.html">Result</a>&lt; T, E &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a447ed31a468b5b86c4d5915d6714822e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a447ed31a468b5b86c4d5915d6714822e">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1Ok.html">Ok</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>cmp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3322cfa60a991ca1999a1e818f4d3449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3322cfa60a991ca1999a1e818f4d3449">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1Ok.html">Ok</a>&lt; <a class="el" href="namespacestx.html#a910046924ff264eb1eec0707011908ee">ConstRef</a>&lt; T &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>cmp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6b651ea06a646951ae69ac54f5040d3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b651ea06a646951ae69ac54f5040d3f">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1Ok.html">Ok</a>&lt; <a class="el" href="namespacestx.html#a1b55420e0cd6b42317f23d32831d1637">MutRef</a>&lt; T &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>cmp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a80d5af6ebec3967a90fc2b53611572f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80d5af6ebec3967a90fc2b53611572f9">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1Ok.html">Ok</a>&lt; T const *&gt; const &amp;&#160;</td>
          <td class="paramname"><em>cmp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a60c88b5dfa94ad4ffb3a7df0630094a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60c88b5dfa94ad4ffb3a7df0630094a5">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1Ok.html">Ok</a>&lt; T *&gt; const &amp;&#160;</td>
          <td class="paramname"><em>cmp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a12125d8fd4877f7a7e192124b6dfe558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12125d8fd4877f7a7e192124b6dfe558">&#9670;&nbsp;</a></span>operator==() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1Err.html">Err</a>&lt; E &gt; const &amp;&#160;</td>
          <td class="paramname"><em>cmp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a65062cfc342a16d5b378fec987306987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65062cfc342a16d5b378fec987306987">&#9670;&nbsp;</a></span>operator==() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1Err.html">Err</a>&lt; <a class="el" href="namespacestx.html#a910046924ff264eb1eec0707011908ee">ConstRef</a>&lt; E &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>cmp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac1944457906018ea84a7f8e90435bc96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1944457906018ea84a7f8e90435bc96">&#9670;&nbsp;</a></span>operator==() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1Err.html">Err</a>&lt; <a class="el" href="namespacestx.html#a1b55420e0cd6b42317f23d32831d1637">MutRef</a>&lt; E &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>cmp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad48d65f962e058d9b76fdde1af7bc9b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad48d65f962e058d9b76fdde1af7bc9b3">&#9670;&nbsp;</a></span>operator==() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1Err.html">Err</a>&lt; E const *&gt; const &amp;&#160;</td>
          <td class="paramname"><em>cmp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab66d61aee2baffadb1935a78fd8c2596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab66d61aee2baffadb1935a78fd8c2596">&#9670;&nbsp;</a></span>operator==() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1Err.html">Err</a>&lt; E *&gt; const &amp;&#160;</td>
          <td class="paramname"><em>cmp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aca545f20e4665b49e47b60b0d2d832ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca545f20e4665b49e47b60b0d2d832ef">&#9670;&nbsp;</a></span>operator==() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstx_1_1Result.html">Result</a>&lt; T, E &gt; const &amp;&#160;</td>
          <td class="paramname"><em>cmp</em></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4dbeda54fa0b32d0f1b76670eb112d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dbeda54fa0b32d0f1b76670eb112d62">&#9670;&nbsp;</a></span>OR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<div class="memtemplate">
template&lt;typename U , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">requires <a class="el" href="namespacestx.html#aa0bd2b8f4938c62598f62d340bd74008">convertible_to</a>&lt;T&amp;&amp;, U&gt; [[nodiscard]] constexpr auto <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::OR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstx_1_1Result.html">Result</a>&lt; U, F &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>alt</em></td><td>)</td>
          <td> &amp;&amp; -&gt; <a class="el" href="classstx_1_1Result.html">Result</a>&lt;U, F&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <code>res</code> if the result is <code><a class="el" href="structstx_1_1Err.html" title="error-value variant for Result&lt;T, E&gt; wrapping the contained error ">Err</a></code>, otherwise returns the <code><a class="el" href="structstx_1_1Ok.html">Ok</a></code> value of itself.</p>
<p>Arguments passed to <code>or</code> are eagerly evaluated; if you are passing the result of a function call, it is recommended to use <code>or_else</code>, which is lazily evaluated.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line">Result&lt;int, string_view&gt; a = Ok(2);</div><div class="line">Result&lt;int, string_view&gt; b = Err(<span class="stringliteral">&quot;late error&quot;</span>sv);</div><div class="line">ASSERT_EQ(move(a).<a class="code" href="classstx_1_1Result.html#a4dbeda54fa0b32d0f1b76670eb112d62">OR</a>(move(b)), Ok(2));</div><div class="line"></div><div class="line">Result&lt;int, string_view&gt; c = Err(<span class="stringliteral">&quot;early error&quot;</span>sv);</div><div class="line">Result&lt;int, string_view&gt; d = Ok(2);</div><div class="line">ASSERT_EQ(move(c).<a class="code" href="classstx_1_1Result.html#a4dbeda54fa0b32d0f1b76670eb112d62">OR</a>(move(d)), Ok(2));</div><div class="line"></div><div class="line">Result&lt;int, string_view&gt; e = Err(<span class="stringliteral">&quot;not a 2&quot;</span>sv);</div><div class="line">Result&lt;int, string_view&gt; f = Err(<span class="stringliteral">&quot;late error&quot;</span>sv);</div><div class="line">ASSERT_EQ(move(e).<a class="code" href="classstx_1_1Result.html#a4dbeda54fa0b32d0f1b76670eb112d62">OR</a>(move(f)), Err(<span class="stringliteral">&quot;late error&quot;</span>sv));</div><div class="line"></div><div class="line">Result&lt;int, string_view&gt; g = Ok(2);</div><div class="line">Result&lt;int, string_view&gt; h = Ok(100);</div><div class="line">ASSERT_EQ(move(g).<a class="code" href="classstx_1_1Result.html#a4dbeda54fa0b32d0f1b76670eb112d62">OR</a>(move(h)), Ok(2));</div></div><!-- fragment --> 
</div>
</div>
<a id="ac0a673a03ae687903ef6af6700f477f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0a673a03ae687903ef6af6700f477f6">&#9670;&nbsp;</a></span>or_else()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">requires <a class="el" href="namespacestx.html#aa8f14c3c14e6dcdecfdf0710ee2ed774">invocable</a>&lt;Fn&amp;&amp;, E&amp;&amp;&gt; [[nodiscard]] constexpr auto <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::or_else </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> &amp;&amp; -&gt; <a class="el" href="namespacestx.html#ac43d924d52c43f451ac8f9a9ae00934b">invoke_result</a>&lt;Fn&amp;&amp;, E&amp;&amp;&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calls <code>op</code> if the result is <code><a class="el" href="structstx_1_1Err.html" title="error-value variant for Result&lt;T, E&gt; wrapping the contained error ">Err</a></code>, otherwise returns the <code><a class="el" href="structstx_1_1Ok.html">Ok</a></code> value of itself.</p>
<p>This function can be used for control flow based on result values.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> <a class="code" href="namespacestx.html#a1754a6b0876636dda571d46f50182507">make_ok</a> = [](<span class="keywordtype">int</span> x) -&gt; Result&lt;int, int&gt; { <span class="keywordflow">return</span> Ok(move(x)); };</div><div class="line"><span class="keyword">auto</span> <a class="code" href="namespacestx.html#aad98263198e88a079235f2845bd1ae09">make_err</a> = [](<span class="keywordtype">int</span> x) -&gt; Result&lt;int, int&gt; { <span class="keywordflow">return</span> Err(move(x)); };</div><div class="line"><span class="keyword">auto</span> sq = [](<span class="keywordtype">int</span> <a class="code" href="classstx_1_1Result.html#a4548a280df6c073e970fb7492e64b738">err</a>) -&gt; Result&lt;int, int&gt; { <span class="keywordflow">return</span> Ok(err * err); };</div><div class="line"><span class="keyword">auto</span> err = [](<span class="keywordtype">int</span> <a class="code" href="classstx_1_1Result.html#a4548a280df6c073e970fb7492e64b738">err</a>) -&gt; Result&lt;int, int&gt; { <span class="keywordflow">return</span> Err(move(err)); };</div><div class="line"></div><div class="line">ASSERT_EQ(<a class="code" href="namespacestx.html#a1754a6b0876636dda571d46f50182507">make_ok</a>(2).<a class="code" href="classstx_1_1Result.html#ac0a673a03ae687903ef6af6700f477f6">or_else</a>(sq).<a class="code" href="classstx_1_1Result.html#ac0a673a03ae687903ef6af6700f477f6">or_else</a>(sq), Ok(2));</div><div class="line">ASSERT_EQ(<a class="code" href="namespacestx.html#a1754a6b0876636dda571d46f50182507">make_ok</a>(2).<a class="code" href="classstx_1_1Result.html#ac0a673a03ae687903ef6af6700f477f6">or_else</a>(err).<a class="code" href="classstx_1_1Result.html#ac0a673a03ae687903ef6af6700f477f6">or_else</a>(sq), Ok(2));</div><div class="line">ASSERT_EQ(<a class="code" href="namespacestx.html#aad98263198e88a079235f2845bd1ae09">make_err</a>(3).<a class="code" href="classstx_1_1Result.html#ac0a673a03ae687903ef6af6700f477f6">or_else</a>(sq).<a class="code" href="classstx_1_1Result.html#ac0a673a03ae687903ef6af6700f477f6">or_else</a>(err), Ok(9));</div><div class="line">ASSERT_EQ(<a class="code" href="namespacestx.html#aad98263198e88a079235f2845bd1ae09">make_err</a>(3).<a class="code" href="classstx_1_1Result.html#ac0a673a03ae687903ef6af6700f477f6">or_else</a>(err).<a class="code" href="classstx_1_1Result.html#ac0a673a03ae687903ef6af6700f477f6">or_else</a>(err), Err(3));</div></div><!-- fragment --> 
</div>
</div>
<a id="a8214d8b604e553a0c4e8780b1dcc45d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8214d8b604e553a0c4e8780b1dcc45d6">&#9670;&nbsp;</a></span>unwrap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::unwrap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp; -&gt; T </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unwraps a result, yielding the content of an <code><a class="el" href="structstx_1_1Ok.html">Ok</a></code>.</p>
<h1>Panics</h1>
<p>Panics if the value is an <code><a class="el" href="structstx_1_1Err.html" title="error-value variant for Result&lt;T, E&gt; wrapping the contained error ">Err</a></code>, with a panic message provided by the <code><a class="el" href="structstx_1_1Err.html" title="error-value variant for Result&lt;T, E&gt; wrapping the contained error ">Err</a></code>'s value.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line">ASSERT_EQ(make_ok&lt;int, string_view&gt;(2).<a class="code" href="classstx_1_1Result.html#a8214d8b604e553a0c4e8780b1dcc45d6">unwrap</a>(), 2);</div><div class="line">Result&lt;int, string_view&gt; x = Err(<span class="stringliteral">&quot;emergency failure&quot;</span>sv);</div><div class="line">ASSERT_ANY_THROW(move(x).<a class="code" href="classstx_1_1Result.html#a8214d8b604e553a0c4e8780b1dcc45d6">unwrap</a>());</div></div><!-- fragment --> 
</div>
</div>
<a id="afe3376a66e7cf9cb15728ba5f4605753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe3376a66e7cf9cb15728ba5f4605753">&#9670;&nbsp;</a></span>unwrap_err()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::unwrap_err </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp; -&gt; E </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unwraps a result, yielding the content of an <code><a class="el" href="structstx_1_1Err.html" title="error-value variant for Result&lt;T, E&gt; wrapping the contained error ">Err</a></code>.</p>
<h1>Panics</h1>
<p>Panics if the value is an <code><a class="el" href="structstx_1_1Ok.html">Ok</a></code>, with a custom panic message provided by the <code><a class="el" href="structstx_1_1Ok.html">Ok</a></code>'s value.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line">Result&lt;int, string_view&gt; x = Ok(2);</div><div class="line">ASSERT_ANY_THROW(move(x).<a class="code" href="classstx_1_1Result.html#afe3376a66e7cf9cb15728ba5f4605753">unwrap_err</a>()); <span class="comment">// panics</span></div><div class="line"></div><div class="line">Result&lt;int, string_view&gt; y = Err(<span class="stringliteral">&quot;emergency failure&quot;</span>sv);</div><div class="line">ASSERT_EQ(move(y).<a class="code" href="classstx_1_1Result.html#afe3376a66e7cf9cb15728ba5f4605753">unwrap_err</a>(), <span class="stringliteral">&quot;emergency failure&quot;</span>);</div></div><!-- fragment --> 
</div>
</div>
<a id="a64ce9a41c7dcdfc6283e33783836cd89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64ce9a41c7dcdfc6283e33783836cd89">&#9670;&nbsp;</a></span>unwrap_or()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::unwrap_or </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>alt</em></td><td>)</td>
          <td> &amp;&amp; -&gt; T </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unwraps a result, yielding the content of an <code><a class="el" href="structstx_1_1Ok.html">Ok</a>&lt;T&gt;</code> variant. Else, it returns the parameter <code>alt</code>.</p>
<p>Arguments passed to <code>unwrap_or</code> are eagerly evaluated; if you are passing the result of a function call, it is recommended to use <code>unwrap_or_else</code>, which is lazily evaluated.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> alt = 2;</div><div class="line">Result&lt;int, string_view&gt; x = Ok(9);</div><div class="line">ASSERT_EQ(move(x).<a class="code" href="classstx_1_1Result.html#a64ce9a41c7dcdfc6283e33783836cd89">unwrap_or</a>(move(alt)), 9);</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> alt_b = 2;</div><div class="line">Result&lt;int, string_view&gt; y = Err(<span class="stringliteral">&quot;error&quot;</span>sv);</div><div class="line">ASSERT_EQ(move(y).<a class="code" href="classstx_1_1Result.html#a64ce9a41c7dcdfc6283e33783836cd89">unwrap_or</a>(move(alt_b)), 2);</div></div><!-- fragment --> 
</div>
</div>
<a id="ae16d2de5c4bf672a51ec7a6c85f70b08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae16d2de5c4bf672a51ec7a6c85f70b08">&#9670;&nbsp;</a></span>unwrap_or_default()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::unwrap_or_default </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp; -&gt; T
      requires <a class="el" href="namespacestx.html#a33c4edb845e3f658de071107790b37bc">default_constructible</a>&lt;T&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the contained value or a default</p>
<p>Consumes itself then, if <code><a class="el" href="structstx_1_1Ok.html">Ok</a></code>, returns the contained value, otherwise if <code><a class="el" href="structstx_1_1Err.html" title="error-value variant for Result&lt;T, E&gt; wrapping the contained error ">Err</a></code>, returns the default value for that type.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line">Result&lt;string, int&gt; good_year = Ok(<span class="stringliteral">&quot;1909&quot;</span>s);</div><div class="line">Result&lt;string, int&gt; bad_year = Err(-1);</div><div class="line"></div><div class="line">ASSERT_EQ(move(good_year).<a class="code" href="classstx_1_1Result.html#ae16d2de5c4bf672a51ec7a6c85f70b08">unwrap_or_default</a>(), <span class="stringliteral">&quot;1909&quot;</span>s);</div><div class="line">ASSERT_EQ(move(bad_year).<a class="code" href="classstx_1_1Result.html#ae16d2de5c4bf672a51ec7a6c85f70b08">unwrap_or_default</a>(), <span class="stringliteral">&quot;&quot;</span>s); <span class="comment">// empty string (&quot;&quot;s)</span></div><div class="line">                                                    <span class="comment">// is the default</span></div><div class="line">                                                    <span class="comment">// value</span></div><div class="line">                                                    <span class="comment">// for a C++ string</span></div></div><!-- fragment --> 
</div>
</div>
<a id="a612bf80b79e2ea742aae33f7e5add3b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a612bf80b79e2ea742aae33f7e5add3b0">&#9670;&nbsp;</a></span>unwrap_or_else()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">requires <a class="el" href="namespacestx.html#aa8f14c3c14e6dcdecfdf0710ee2ed774">invocable</a>&lt;Fn&amp;&amp;, E&amp;&amp;&gt; [[nodiscard]] constexpr auto <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::unwrap_or_else </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> &amp;&amp; -&gt; T </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unwraps a result, yielding the content of an <code><a class="el" href="structstx_1_1Ok.html">Ok</a></code>. If the value is an <code><a class="el" href="structstx_1_1Err.html" title="error-value variant for Result&lt;T, E&gt; wrapping the contained error ">Err</a></code> then it calls <code>op</code> with its value.</p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> count = [] (string_view <a class="code" href="classstx_1_1Result.html#a4548a280df6c073e970fb7492e64b738">err</a>)  { <span class="keywordflow">return</span> err.size(); };</div><div class="line"></div><div class="line">ASSERT_EQ(make_ok&lt;size_t,string_view&gt;(2UL).<a class="code" href="classstx_1_1Result.html#a612bf80b79e2ea742aae33f7e5add3b0">unwrap_or_else</a>(count), 2);</div><div class="line">ASSERT_EQ(make_err&lt;size_t,string_view&gt;(<span class="stringliteral">&quot;booo&quot;</span>sv).<a class="code" href="classstx_1_1Result.html#a612bf80b79e2ea742aae33f7e5add3b0">unwrap_or_else</a>(count),</div><div class="line">4);</div></div><!-- fragment --> 
</div>
</div>
<a id="a00c0c5eaa92721eb93ac36733bc8efc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00c0c5eaa92721eb93ac36733bc8efc9">&#9670;&nbsp;</a></span>value() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an l-value reference to the contained value. Note that no copying occurs here.</p>
<h1>Panics</h1>
<p>Panics if the value is an <code><a class="el" href="structstx_1_1Err.html" title="error-value variant for Result&lt;T, E&gt; wrapping the contained error ">Err</a></code></p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> result = make_ok&lt;int, int&gt;(6);</div><div class="line"><span class="keywordtype">int</span>&amp; value = result.value();</div><div class="line">value = 97;</div><div class="line"></div><div class="line">ASSERT_EQ(result, Ok(97));</div></div><!-- fragment --> 
</div>
</div>
<a id="acc665cf1430c9e91a13931fe4681460a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc665cf1430c9e91a13931fe4681460a">&#9670;&nbsp;</a></span>value() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T const&amp; <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an l-value reference to the contained value. Note that no copying occurs here.</p>
<h1>Panics</h1>
<p>Panics if the value is an <code><a class="el" href="structstx_1_1Err.html" title="error-value variant for Result&lt;T, E&gt; wrapping the contained error ">Err</a></code></p>
<h1>Examples</h1>
<p>Basic usage:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> <span class="keyword">const</span> result = make_ok&lt;int, int&gt;(6);</div><div class="line"><span class="keywordtype">int</span> <span class="keyword">const</span>&amp; value = result.value();</div><div class="line"></div><div class="line">ASSERT_EQ(value, 6);</div></div><!-- fragment --> 
</div>
</div>
<a id="ae844f3dbacf73f29b78957abeefb85c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae844f3dbacf73f29b78957abeefb85c0">&#9670;&nbsp;</a></span>value() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use <code><a class="el" href="classstx_1_1Result.html#a8214d8b604e553a0c4e8780b1dcc45d6">unwrap()</a></code> instead. </p>

</div>
</div>
<a id="a4baa7aea8724b017437bce47b7023ff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4baa7aea8724b017437bce47b7023ff8">&#9670;&nbsp;</a></span>value() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T const <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use <code><a class="el" href="classstx_1_1Result.html#a8214d8b604e553a0c4e8780b1dcc45d6">unwrap()</a></code> instead. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a24227aa96985cfaaa535c6d7946b6b0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24227aa96985cfaaa535c6d7946b6b0c">&#9670;&nbsp;</a></span>storage_err_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">E <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::storage_err_</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5a38add5b6bf271988836bc4a212434e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a38add5b6bf271988836bc4a212434e">&#9670;&nbsp;</a></span>storage_value_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Swappable T, Swappable E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classstx_1_1Result.html">stx::Result</a>&lt; T, E &gt;::storage_value_</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/stx/internal/<a class="el" href="option__result_8h_source.html">option_result.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer" />
<address class="footer"><small>
    Generated by &#160;<a href="http://www.doxygen.org/index.html"> Doxygen
    </a> 1.8.13
  </small></address>
<script type="text/javascript">
  (() => {
    document.body.onload = (() => {
      //
      //
      let clipboard_icon = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"\
      class="copy-icon dimming-wrap">\
      <path d="M0 0h24v24H0z"  fill="none"/>\
      <path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 \
      2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/>\
      </svg>';
      for (let x of document.querySelectorAll("div.fragment")) {
        if (x.querySelector(".lineno") == null)
          x.innerHTML = clipboard_icon + x.innerHTML;
      };
      for (let copy_icon of document.querySelectorAll(".copy-icon")) {
        copy_icon.onclick = () => {
          let code_content = "";
          for (let line of copy_icon.parentElement.querySelectorAll(".line")) {
            code_content = code_content.concat(line.textContent);
            code_content = code_content.concat("\n");
          }
          navigator.clipboard.writeText(code_content);
          alert("Copied to Clipboard");
        };
      };
    });
  })();
</script>
</body>
</html>